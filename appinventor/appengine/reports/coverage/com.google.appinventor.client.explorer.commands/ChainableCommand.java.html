<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChainableCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.explorer.commands</a> &gt; <span class="el_source">ChainableCommand.java</span></div><h1>ChainableCommand.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.explorer.commands;

import com.google.appinventor.client.Ode;
import com.google.appinventor.client.explorer.project.Project;
import com.google.appinventor.client.tracking.Tracking;
import com.google.appinventor.shared.rpc.project.ProjectNode;
import com.google.common.base.Preconditions;
import com.google.gwt.core.client.Duration;
import com.google.gwt.user.client.Command;

/**
 * Abstract base class for chainable commands that perform some action on a
 * {@link ProjectNode}. A command may be synchronous or asynchronous.
 *
 * &lt;p/&gt;Each subclass must implement {@link #willCallExecuteNextCommand}.
 *
 * &lt;p/&gt;Each subclass whose willCallExecuteNextCommand returns true,
 * must call {@link #executeNextCommand} after its own command has completed
 * successfully and must call {@link #executionFailedOrCanceled} if its own
 * command execution fails or has been canceled.
 *
 * @author lizlooney@google.com (Liz Looney)
 */
public abstract class ChainableCommand {
  // The next chainable command to be executed after this one is finished.
  private final ChainableCommand nextCommand;

  // Tracks elapsed time for entire chain
  private Duration chainDuration;
  // Tracks elapsed time for this command within the chain
  private Duration linkDuration;

  // Name of action this chain of commands represents (for analytics tracking purposes)
  private String actionName;

  // A command to execute after the chain is finished, regardless of whether it succeeds.
  // If any link in the chain is unable to call the next command (willCallExecuteNextCommand
  // returns false), the finallyCommand will be executed immediately after that link's execute
  // method returns.
  private Command finallyCommand;


  /**
   * Creates a new command.
   */
  public ChainableCommand() {
<span class="nc" id="L53">    this(null);</span>
<span class="nc" id="L54">  }</span>

  /**
   * Creates a new command.
   *
   * @param nextCommand the command to execute after this command has completed
   */
<span class="nc" id="L61">  public ChainableCommand(ChainableCommand nextCommand) {</span>
<span class="nc" id="L62">    this.nextCommand = nextCommand;</span>
<span class="nc" id="L63">  }</span>

  /**
   * Initializes the tracking information on each link in the chain
   *
   * @param actionName the name of action this chain of commands represents
   * @param chainDuration duration to be used for the entire chain
   */
  private void initTrackingInformation(String actionName, Duration chainDuration) {
<span class="nc" id="L72">    this.actionName = actionName;</span>
    // Note that all links in the chain have a reference to the same chainDuration.
<span class="nc" id="L74">    this.chainDuration = chainDuration;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">    if (nextCommand != null) {</span>
<span class="nc" id="L76">      nextCommand.initTrackingInformation(actionName, chainDuration);</span>
    }
<span class="nc" id="L78">  }</span>

  /**
   * Resets the start time for the link duration timer
   *
   */
  private final void resetLinkDuration() {
    // Note that each link in the chain has a unique linkDuration.
<span class="nc" id="L86">    linkDuration = new Duration();</span>
<span class="nc" id="L87">  }</span>

  /**
   * Returns the elapsed milliseconds that this link took to execute
   *
   */
  protected final int getElapsedMillis() {
<span class="nc" id="L94">    return linkDuration.elapsedMillis();</span>
  }

  /**
   * Method that needs to be overridden by subclasses to indicate whether
   * or not they will call executeNextCommand when done and
   * executionFailedOrCanceled upon failure/cancelation.
   *
   * &lt;p/&gt;This method should only return false if the subclass cannot determine
   * when it has finished.
   */
  protected abstract boolean willCallExecuteNextCommand();

  /**
   * Kick off the chain of commands.
   *
   * @param actionName the name of action this chain of commands represents
   * @param node the project node to which the chain of commands is applied
   */
  public final void startExecuteChain(String actionName, ProjectNode node) {
<span class="nc" id="L114">    startExecuteChain(actionName, node, null);</span>
<span class="nc" id="L115">  }</span>

  /**
   * Kick off the chain of commands.
   *
   * @param actionName the name of action this chain of commands represents
   * @param node the project node to which the chain of commands is applied
   * @param finallyCommand a command to execute after the chain is finished,
   *                       regardless of whether it succeeds
   */
  public final void startExecuteChain(String actionName, ProjectNode node,
      Command finallyCommand) {
    // The node must not be null.
    // If you are calling startExecuteChain with null for the node parameter, maybe you should
    // question why you are using a ChainableCommand at all. ChainableCommands were designed to
    // perform an operation on a ProjectNode.
<span class="nc" id="L131">    Preconditions.checkNotNull(node);</span>

<span class="nc" id="L133">    setFinallyCommand(finallyCommand);</span>
<span class="nc" id="L134">    initTrackingInformation(actionName, new Duration());</span>

<span class="nc" id="L136">    executeLink(node);</span>
<span class="nc" id="L137">  }</span>

  private final void executeLink(ProjectNode node) {
<span class="nc" id="L140">    resetLinkDuration();</span>
<span class="nc" id="L141">    execute(node);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    if (!willCallExecuteNextCommand()) {</span>
      // If this command won't end up calling executeNextCommand, execute the finally command
      // and do the tracking now. This may result in underestimating the overall time (should we
      // skip the time estimates in this case?).
<span class="nc" id="L146">      executeFinallyCommand();</span>
<span class="nc" id="L147">      track(node);</span>
    }
<span class="nc" id="L149">  }</span>

  /**
   * Method that needs to be overridden by subclasses to implement the
   * actual behavior of the command.  Do not call this directly (call
   * startExecuteChain instead)!
   *
   * @param node the project node to which the command is applied
   */
  protected abstract void execute(ProjectNode node);

  /**
   * Check if the command can be used for the project node.
   * @param node the project node to which the command is applied
   * @return
   */
  protected boolean isSupported(ProjectNode node) {
<span class="nc" id="L166">    return true;</span>
  }

  /**
   * Executes the next command in the chain.
   *
   * @param node the project node to which the command is applied
   */
  protected final void executeNextCommand(ProjectNode node) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (nextCommand != null) {</span>
<span class="nc" id="L176">      nextCommand.executeLink(node);</span>
    } else {
      // This is the end of the chain. Execute the finally command and track.
<span class="nc" id="L179">      executeFinallyCommand();</span>
<span class="nc" id="L180">      track(node);</span>
    }
<span class="nc" id="L182">  }</span>

  /**
   * Indicates that this command's execution has failed or has been canceled.
   */
  protected final void executionFailedOrCanceled() {
<span class="nc" id="L188">    executeFinallyCommand();</span>
<span class="nc" id="L189">  }</span>

  /**
   * Sets a command to execute after the chain is finished, regardless of
   * whether it succeeds.
   *
   * @param finallyCommand a command to execute after the chain is finished,
   *                       regardless of whether it succeeds
   */
  private void setFinallyCommand(Command finallyCommand) {
    // Set the finallyCommand field on each link in the chain.
<span class="nc" id="L200">    this.finallyCommand = finallyCommand;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">    if (nextCommand != null) {</span>
<span class="nc" id="L202">      nextCommand.setFinallyCommand(finallyCommand);</span>
    }
<span class="nc" id="L204">  }</span>

  private void executeFinallyCommand() {
<span class="nc bnc" id="L207" title="All 2 branches missed.">    if (finallyCommand != null) {</span>
<span class="nc" id="L208">      finallyCommand.execute();</span>
    }
<span class="nc" id="L210">  }</span>

  private void track(ProjectNode node) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">    if (!actionName.isEmpty()) {</span>
<span class="nc" id="L214">      Tracking.trackEvent(Tracking.PROJECT_EVENT, actionName,</span>
<span class="nc" id="L215">          node.getName(), chainDuration.elapsedMillis());</span>
    }
<span class="nc" id="L217">  }</span>

  /**
   * Returns the project a node belongs to.
   *
   * @param node the node for which to determine the project
   */
  protected final Project getProject(ProjectNode node) {
<span class="nc" id="L225">    return Ode.getInstance().getProjectManager().getProject(node);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>