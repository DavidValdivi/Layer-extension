<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DragSourceSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.widgets.dnd</a> &gt; <span class="el_source">DragSourceSupport.java</span></div><h1>DragSourceSupport.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2017 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.widgets.dnd;

import com.google.appinventor.client.editor.simple.components.MockComponent;
import com.google.appinventor.client.output.OdeLog;
import com.google.gwt.user.client.Command;
import com.google.gwt.user.client.DOM;
import com.google.gwt.user.client.DeferredCommand;
import com.google.gwt.user.client.Element;
import com.google.gwt.user.client.ui.MouseListener;
import com.google.gwt.user.client.ui.PopupPanel;
import com.google.gwt.user.client.ui.UIObject;
import com.google.gwt.user.client.ui.Widget;
import com.google.gwt.event.dom.client.TouchStartHandler;
import com.google.gwt.event.dom.client.TouchMoveHandler;
import com.google.gwt.event.dom.client.TouchEndHandler;
import com.google.gwt.event.dom.client.TouchCancelHandler;
import com.google.gwt.event.dom.client.TouchStartEvent;
import com.google.gwt.event.dom.client.TouchMoveEvent;
import com.google.gwt.event.dom.client.TouchCancelEvent;
import com.google.gwt.event.dom.client.TouchEndEvent;
import com.google.gwt.dom.client.Touch;

/**
 * Provides support for dragging from a {@link DragSource}
 * (typically a widget) to a {@link DropTarget}.
 *
 */
public final class DragSourceSupport implements MouseListener, TouchStartHandler, TouchMoveHandler, TouchCancelHandler, TouchEndHandler {
  /**
   * Interface to functionality provided by the {@link DOM} class.
   * Used as a testing seam.
   *
   */
  // @VisibleForTesting
  static interface IDom {
    public void setCapture(Element elem);
    public void releaseCapture(Element elem);
    public void eventPreventDefaultOfCurrentEvent();
    public com.google.gwt.dom.client.Element getFromElementOfCurrentEvent();
    public com.google.gwt.dom.client.Element getToElementOfCurrentEvent();
  }

  /**
   * Implementation of {@link IDom} that delegates to the real
   * {@link DOM} class.
   *
   */
  private static class RealDom implements IDom {
<span class="nc" id="L55">    private static final RealDom INSTANCE = new RealDom();</span>

    /**
     * Prevent instantiation of static class.
     */
    private RealDom() {
      // nothing
    }

    public void setCapture(Element elem) {
<span class="nc" id="L65">      DOM.setCapture(elem);</span>
<span class="nc" id="L66">    }</span>

    public void releaseCapture(Element elem) {
<span class="nc" id="L69">      DOM.releaseCapture(elem);</span>
<span class="nc" id="L70">    }</span>

    public void eventPreventDefaultOfCurrentEvent() {
<span class="nc" id="L73">      DOM.eventPreventDefault(DOM.eventGetCurrentEvent());</span>
<span class="nc" id="L74">    }</span>

    public com.google.gwt.dom.client.Element getFromElementOfCurrentEvent() {
<span class="nc" id="L77">      return DOM.eventGetCurrentEvent().getFromElement();</span>
    }

    public com.google.gwt.dom.client.Element getToElementOfCurrentEvent() {
<span class="nc" id="L81">      return DOM.eventGetCurrentEvent().getToElement();</span>
    }
  }

  /**
   * This class is used to show a widget while dragging. This could be anything
   * from a simple outline to a copy of the {@code DragSource} widget.
   */
  private static class DragWidgetPopup extends PopupPanel {
    public DragWidgetPopup(Widget w) {
<span class="nc" id="L91">      super(true);</span>
<span class="nc" id="L92">      setWidget(w);</span>
<span class="nc" id="L93">    }</span>
  }

  /**
   * Number of pixels away from the click-point that a drag-source must be
   * dragged to initiate a drag action.
   */
  // @VisibleForTesting
  static final int DRAG_THRESHOLD = 5;

  // Provider of the drag widget and the set of permissible drop targets
  private final DragSource dragSource;
  // DOM implementation
  private final IDom dom;

  // Location (in the drag-widget coordinate system) where the last mouse-down originated.
  // When a drag is in progress, this is the origin of the click that initiated the drag.
  private int startX;
  private int startY;

  private boolean captured;
  private boolean mouseIsDown;
  private boolean dragInProgress;

  // Location (in the drag-widget coordinate system) where the last mouse-move originated
  // while the mouse button was down.
  private int dragX;
  private int dragY;

  // Array of widgets that the drag source widget can be dropped on
  private DropTarget[] dropTargets;

  // Popup containing the widget being shown while dragging
  private DragWidgetPopup dragWidgetPopup;

  // The drop target that the cursor is hovering over currently
  private DropTarget hoverDropTarget;

  /**
   * Creates a new instance of this class to provide support for dragging
   * from the specified drag source to any of the drop targets that it defines.
   * &lt;p&gt;
   * After creation, the caller must add this {@link DragSourceSupport} as
   * a {@link MouseListener} to whatever actual {@link UIObject} will
   * receive drag gestures.
   */
  public DragSourceSupport(DragSource dragSource) {
<span class="nc" id="L140">    this(dragSource, RealDom.INSTANCE);</span>
<span class="nc" id="L141">  }</span>

  // @VisibleForTesting
<span class="nc" id="L144">  DragSourceSupport(DragSource dragSource, IDom dom) {</span>
<span class="nc" id="L145">    this.dragSource = dragSource;</span>
<span class="nc" id="L146">    this.dom = dom;</span>

<span class="nc" id="L148">    startX = -1;</span>
<span class="nc" id="L149">    startY = -1;</span>
<span class="nc" id="L150">    mouseIsDown = false;</span>
<span class="nc" id="L151">    dragInProgress = false;</span>
<span class="nc" id="L152">    dragX = -1;</span>
<span class="nc" id="L153">    dragY = -1;</span>

<span class="nc" id="L155">    dropTargets = null;</span>
<span class="nc" id="L156">    dragWidgetPopup = null;</span>
<span class="nc" id="L157">    hoverDropTarget = null;</span>
<span class="nc" id="L158">  }</span>

  // Private utility methods

  /**
   * Clears any existing selections in the browser.
   * &lt;p&gt;
   * While we are normally trying to avoid falling back to using embedded Javascript, it seems
   * that this cannot currently be done using the GWT APIs.
   */
  private static native void clearSelections() /*-{
    try {
      if ($doc.selection &amp;&amp; $doc.selection.empty) {
        $doc.selection.empty();
      } else if ($wnd.getSelection) {
        var sel = $wnd.getSelection();
        if (sel) {
          if (sel.removeAllRanges) {
            sel.removeAllRanges();
          }
          if (sel.collapse) {
            sel.collapse(null, 0);
          }
        }
      }
    } catch (ignore) {
      // Well, we tried...
    }
  }-*/;

  /**
   * Returns whether the specified widget contains a position given
   * by the absolute coordinates.
   *
   * @param w  widget to test
   * @param absX  absolute x coordinate of position
   * @param absY  absolute y coordinate of position
   * @return  {@code true} if the position is within the widget, {@code false}
   *          otherwise
   */
  private static boolean isInside(Widget w, int absX, int absY) {
<span class="nc" id="L199">    int wx = w.getAbsoluteLeft();</span>
<span class="nc" id="L200">    int wy = w.getAbsoluteTop();</span>
<span class="nc" id="L201">    int ww = w.getOffsetWidth();</span>
<span class="nc" id="L202">    int wh = w.getOffsetHeight();</span>

<span class="nc bnc" id="L204" title="All 8 branches missed.">    return (wx &lt;= absX) &amp;&amp; (absX &lt; wx + ww) &amp;&amp; (wy &lt;= absY) &amp;&amp; (absY &lt; wy + wh);</span>
  }

  // Drag-widget positioning

  /**
   * Configures the specified drag-widget (that will be returned by
   * {@link DragSource#createDragWidget(int, int)}) so that the cursor's hot spot
   * will appear at the point (x,y) in the widget's coordinate system.
   */
  public static void configureDragWidgetToAppearWithCursorAt(Widget w, int x, int y) {
<span class="nc" id="L215">    Element e = w.getElement();</span>
<span class="nc" id="L216">    DOM.setStyleAttribute(e, &quot;position&quot;, &quot;absolute&quot;);</span>
<span class="nc" id="L217">    DOM.setStyleAttribute(e, &quot;left&quot;, -x + &quot;px&quot;);</span>
<span class="nc" id="L218">    DOM.setStyleAttribute(e, &quot;top&quot;, -y + &quot;px&quot;);</span>
<span class="nc" id="L219">  }</span>

  /**
   * Returns the x-coordinate where the cursor appears in the specified
   * drag-widget's coordinate system.
   */
  private static int getDragWidgetOffsetX(Widget w) {
<span class="nc" id="L226">    return -parsePixelValue(DOM.getStyleAttribute(w.getElement(), &quot;left&quot;));</span>
  }

  /**
   * Returns the y-coordinate where the cursor appears in the specified
   * drag-widget's coordinate system.
   */
  private static int getDragWidgetOffsetY(Widget w) {
<span class="nc" id="L234">    return -parsePixelValue(DOM.getStyleAttribute(w.getElement(), &quot;top&quot;));</span>
  }

  private static int parsePixelValue(String pixelValueStr) {
<span class="nc bnc" id="L238" title="All 4 branches missed.">    if ((pixelValueStr != null) &amp;&amp; pixelValueStr.endsWith(&quot;px&quot;)) {</span>
      try {
<span class="nc" id="L240">        return Integer.parseInt(pixelValueStr.substring(0, pixelValueStr.length() - &quot;px&quot;.length()));</span>
<span class="nc" id="L241">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L242">        return 0;</span>
      }
    } else {
<span class="nc" id="L245">      return 0;</span>
    }
  }

  // MouseListener implementation

  @Override
  public void onMouseDown(Widget sender, int x, int y) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">    if (mouseIsDown) {</span>
<span class="nc" id="L254">      OdeLog.wlog(&quot;received onMouseDown event when we thought the mouse was already down&quot;);</span>
    }
<span class="nc" id="L256">    mouseIsDown = true;</span>

<span class="nc" id="L258">    startX = x;</span>
<span class="nc" id="L259">    startY = y;</span>

<span class="nc bnc" id="L261" title="All 2 branches missed.">    if (!captured) {</span>
      // Force browser to keep sending us events until the mouse is released
<span class="nc" id="L263">      dom.setCapture(sender.getElement());</span>
<span class="nc" id="L264">      captured = true;</span>
    }

    // Prevent default actions like image-dragging and text selections from being triggered
<span class="nc" id="L268">    dom.eventPreventDefaultOfCurrentEvent();</span>
    // TODO(user): Consider removing this, since it seems to have
    //                    less effect (at least on Firefox 2) than the line above,
    //                    is more complex, and is browser-dependent.
<span class="nc" id="L272">    DeferredCommand.addCommand(new Command() {</span>
      @Override
      public void execute() {
<span class="nc" id="L275">        clearSelections();</span>
<span class="nc" id="L276">      }</span>
    });
<span class="nc" id="L278">  }</span>

  // NOTE: At least in Firefox 2, if the user drags outside of the browser window,
  //       mouse-move (and even mouse-down) events will not be received until
  //       the user drags back inside the window. A workaround for this issue
  //       exists in the implementation for onMouseLeave().
  @Override
  public void onMouseMove(Widget sender, int x, int y) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">    if (mouseIsDown) {</span>
<span class="nc" id="L287">      dragX = x;</span>
<span class="nc" id="L288">      dragY = y;</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (dragInProgress) {</span>
<span class="nc" id="L291">        onDragContinue(sender, x, y);</span>
      } else {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        dragInProgress = (manhattanDist(x, y, startX, startY) &gt;= DRAG_THRESHOLD);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (dragInProgress) {</span>
<span class="nc" id="L295">          onDragStart(sender, x, y);</span>

          // Check whether we are already hovering over a potential drop target
<span class="nc" id="L298">          onDragContinue(sender, x, y);</span>
        }
      }

      // Prevent default actions from being triggered
<span class="nc" id="L303">      dom.eventPreventDefaultOfCurrentEvent();</span>
    }
<span class="nc" id="L305">  }</span>

  @Override
  public void onMouseUp(Widget sender, int x, int y) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">    if (!mouseIsDown) {</span>
<span class="nc" id="L310">      OdeLog.wlog(&quot;received onMouseUp event when we thought the mouse was already up&quot;);</span>
    }
<span class="nc" id="L312">    mouseIsDown = false;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (captured) {</span>
      // Allow other elements to receive events after the drag/click
<span class="nc" id="L316">      dom.releaseCapture(sender.getElement());</span>
<span class="nc" id="L317">      captured = false;</span>
    }

<span class="nc bnc" id="L320" title="All 2 branches missed.">    if (dragInProgress) {</span>
<span class="nc" id="L321">      onDragEnd(sender, x, y);</span>
    }

<span class="nc" id="L324">    startX = -1;</span>
<span class="nc" id="L325">    startY = -1;</span>
<span class="nc" id="L326">    dragInProgress = false;</span>

    // Prevent default actions from being triggered
<span class="nc" id="L329">    dom.eventPreventDefaultOfCurrentEvent();</span>
<span class="nc" id="L330">  }</span>

  @Override
  public void onMouseEnter(Widget sender) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (dragInProgress) {</span>
      // Firefox 2 specific. IE6 does not need this.
<span class="nc bnc" id="L336" title="All 2 branches missed.">      if (dom.getFromElementOfCurrentEvent() == getDragWidget().getElement() &amp;&amp;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">          isRootHtmlElement(dom.getToElementOfCurrentEvent())) {</span>
        // The user moved the mouse outside the browser window.
        //
        // Simulate a mouse-moved event to a position offscreen,
        // since this is not done automatically in Firefox 2.
<span class="nc" id="L342">        onMouseMove(sender,</span>
<span class="nc" id="L343">            /*localX*/ (/*absX*/ -1) - sender.getAbsoluteLeft(),</span>
<span class="nc" id="L344">            /*localY*/ (/*absY*/ -1) - sender.getAbsoluteTop());</span>
<span class="nc" id="L345">        return;</span>
      }
    }
<span class="nc" id="L348">  }</span>

  @Override
  public void onMouseLeave(Widget sender) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (dragInProgress) {</span>
      // Firefox 2 specific. IE6 does not need this.
<span class="nc bnc" id="L354" title="All 2 branches missed.">      if (isRootHtmlElement(dom.getFromElementOfCurrentEvent()) &amp;&amp;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">          dom.getToElementOfCurrentEvent() == null) {</span>
        // The user released the mouse button while
        // the mouse was outside the browser window.
        //
        // Simulate a mouse-release event, since this
        // is not done automatically in Firefox 2.
<span class="nc" id="L361">        onMouseUp(sender, dragX, dragY);</span>
<span class="nc" id="L362">        return;</span>
      }
    }
<span class="nc" id="L365">  }</span>

  private static int manhattanDist(int x1, int y1, int x2, int y2) {
<span class="nc" id="L368">    return Math.abs(x1 - x2) + Math.abs(y1 - y2);</span>
  }

  /**
   * Returns whether the specified element is the root HTML element of the web page.
   */
  private static boolean isRootHtmlElement(com.google.gwt.dom.client.Element element) {
<span class="nc" id="L375">    return &quot;html&quot;.equalsIgnoreCase(element.getTagName());</span>
  }

  /**
   * Returns the drag widget created by the last call to
   * {@link DragSource#createDragWidget(int, int)}.
   */
  public Widget getDragWidget() {
<span class="nc" id="L383">    return dragWidgetPopup.getWidget();</span>
  }

  // Touch Handler Implementation

  /**
   * Call the equivalent mouse event handler for each touch event
   */
  @Override
  public void onTouchStart(TouchStartEvent event) {
<span class="nc" id="L393">    event.preventDefault();</span>
<span class="nc" id="L394">    Widget src = (Widget) event.getSource();</span>
<span class="nc" id="L395">    Touch touch = event.getTargetTouches().get(0);</span>
<span class="nc" id="L396">    com.google.gwt.dom.client.Element target = com.google.gwt.dom.client.Element.as(touch.getTarget());</span>
<span class="nc" id="L397">    int x = touch.getRelativeX(target);</span>
<span class="nc" id="L398">    int y = touch.getRelativeY(target);</span>
<span class="nc" id="L399">    onMouseDown(src, x, y);</span>
<span class="nc" id="L400">  }</span>

  @Override
  public void onTouchMove(TouchMoveEvent event) {
<span class="nc" id="L404">    Widget src = (Widget) event.getSource();</span>
<span class="nc" id="L405">    Touch touch = event.getTargetTouches().get(0);</span>
<span class="nc" id="L406">    com.google.gwt.dom.client.Element target = com.google.gwt.dom.client.Element.as(touch.getTarget());</span>
<span class="nc" id="L407">    int x = touch.getRelativeX(target);</span>
<span class="nc" id="L408">    int y = touch.getRelativeY(target);</span>
<span class="nc" id="L409">    onMouseMove(src, x, y);</span>
<span class="nc" id="L410">  }</span>

  @Override
  public void onTouchEnd(final TouchEndEvent event) {
<span class="nc" id="L414">    final Widget src = (Widget) event.getSource();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">    if (src instanceof MockComponent) {  // We only select on CLICK, which isn't generated on mobile</span>
<span class="nc" id="L416">      DeferredCommand.addCommand(new Command() {</span>
        @Override
        public void execute() {
<span class="nc" id="L419">          ((MockComponent) src).select(event.getNativeEvent());</span>
<span class="nc" id="L420">        }</span>
      });
    }
<span class="nc" id="L423">    onMouseUp(src, dragX, dragY);</span>
<span class="nc" id="L424">  }</span>

  @Override
  public void onTouchCancel(TouchCancelEvent event) {
<span class="nc" id="L428">    Widget src = (Widget) event.getSource();</span>
<span class="nc" id="L429">    onMouseLeave(src);</span>
<span class="nc" id="L430">  }</span>

  // Drag handling

  private void onDragStart(Widget sender, int x, int y) {
    // Notify drag source of the drag starting
<span class="nc" id="L436">    dragSource.onDragStart();</span>

    // Cache the set of permissible drop targets
<span class="nc" id="L439">    dropTargets = dragSource.getDropTargets();</span>

    // Show drag proxy widget
<span class="nc" id="L442">    dragWidgetPopup = new DragWidgetPopup(dragSource.createDragWidget(startX, startY));</span>
<span class="nc" id="L443">    dragWidgetPopup.setPopupPosition(</span>
<span class="nc" id="L444">        /*absX*/ x + sender.getAbsoluteLeft(),</span>
<span class="nc" id="L445">        /*absY*/ y + sender.getAbsoluteTop());</span>
<span class="nc" id="L446">    dragWidgetPopup.show();</span>

    // Initialize hover state
<span class="nc" id="L449">    hoverDropTarget = null;</span>
<span class="nc" id="L450">  }</span>

  private void onDragContinue(Widget sender, int x, int y) {
<span class="nc" id="L453">    int absX = x + sender.getAbsoluteLeft();</span>
<span class="nc" id="L454">    int absY = y + sender.getAbsoluteTop();</span>

    // Move drag proxy to new position
<span class="nc" id="L457">    dragWidgetPopup.setPopupPosition(absX, absY);</span>

    // Find drop target that the cursor is currently hovering over
<span class="nc bnc" id="L460" title="All 2 branches missed.">    for (DropTarget target : dropTargets) {</span>
<span class="nc" id="L461">      Widget targetWidget = target.getDropTargetWidget();</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">      if (target == sender) {</span>
        // can't drop onto self - only an issue if sender is a container
<span class="nc" id="L464">        continue;</span>
      }

<span class="nc" id="L467">      boolean isInsideTargetWidget = isInside(targetWidget, absX, absY);</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">      if (target == hoverDropTarget) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (isInsideTargetWidget) {</span>
          // The last identified drop-target &quot;captures&quot; the attention
          // of the drag and drop system while the user is still dragging
          // within its bounds and no other contained drop target accepts the drag
<span class="nc" id="L474">          break;</span>
        } else {
          // Drag has left the bounds of the current hover-target
<span class="nc" id="L477">          hoverDropTarget.onDragLeave(dragSource);</span>
<span class="nc" id="L478">          hoverDropTarget = null;</span>

          // Continue searching for enclosing and non-intersecting
          // drop targets to accept the current drag
<span class="nc" id="L482">          continue;</span>
        }
      }

<span class="nc bnc" id="L486" title="All 2 branches missed.">      if (isInsideTargetWidget) {</span>
<span class="nc" id="L487">        int localX = absX - targetWidget.getAbsoluteLeft();</span>
<span class="nc" id="L488">        int localY = absY - targetWidget.getAbsoluteTop();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (target.onDragEnter(dragSource, localX, localY)) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">          if (hoverDropTarget != null) {</span>
            // Drag exits the old hover-target because it has entered
            // the bounds of an accepting drop target that is within
            // the bounds of the old hover-target
<span class="nc" id="L494">            hoverDropTarget.onDragLeave(dragSource);</span>
          }

          // Drag accepted; current target becomes the new hover-target
<span class="nc" id="L498">          hoverDropTarget = target;</span>

          // The guaranteed onDragContinue() event that follows all invocations
          // of onDragEnter() that accept the drag is fired later in this method
<span class="nc" id="L502">          break;</span>
        }
      }
    }

    // Inform the hover-target of the continuing drag
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (hoverDropTarget != null) {</span>
<span class="nc" id="L509">      Widget targetWidget = hoverDropTarget.getDropTargetWidget();</span>
<span class="nc" id="L510">      hoverDropTarget.onDragContinue(dragSource,</span>
<span class="nc" id="L511">          /*localX*/ absX - targetWidget.getAbsoluteLeft(),</span>
<span class="nc" id="L512">          /*localY*/ absY - targetWidget.getAbsoluteTop());</span>
    }
<span class="nc" id="L514">  }</span>

  private void onDragEnd(Widget sender, int x, int y) {
    // Make sure the current hover-target is still valid,
    // and send the guaranteed onDragContinue() prior to onDrop()
<span class="nc" id="L519">    onDragContinue(sender, x, y);</span>

    // Hide drag widget popup
<span class="nc" id="L522">    dragWidgetPopup.hide();</span>

    // Inform the hover-target of the drop
<span class="nc bnc" id="L525" title="All 2 branches missed.">    if (hoverDropTarget != null) {</span>
<span class="nc" id="L526">      Widget targetWidget = hoverDropTarget.getDropTargetWidget();</span>
<span class="nc" id="L527">      Widget dragWidget = getDragWidget();</span>
<span class="nc" id="L528">      hoverDropTarget.onDrop(dragSource,</span>
<span class="nc" id="L529">          /*localX*/ (/*absX*/ x + sender.getAbsoluteLeft()) - targetWidget.getAbsoluteLeft(),</span>
<span class="nc" id="L530">          /*localY*/ (/*absY*/ y + sender.getAbsoluteTop()) - targetWidget.getAbsoluteTop(),</span>
<span class="nc" id="L531">          getDragWidgetOffsetX(dragWidget),</span>
<span class="nc" id="L532">          getDragWidgetOffsetY(dragWidget));</span>
    }

    // Notify drag source of the drag end
<span class="nc" id="L536">    dragSource.onDragEnd();</span>

    // Clean up
<span class="nc" id="L539">    dropTargets = null;</span>
<span class="nc" id="L540">    dragWidgetPopup = null;</span>
<span class="nc" id="L541">    hoverDropTarget = null;</span>
<span class="nc" id="L542">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>