<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProjectServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.server</a> &gt; <span class="el_source">ProjectServiceImpl.java</span></div><h1>ProjectServiceImpl.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2022 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.server;

import com.google.appinventor.common.version.AppInventorFeatures;

import com.google.appinventor.server.flags.Flag;
import com.google.appinventor.server.project.CommonProjectService;
import com.google.appinventor.server.project.youngandroid.YoungAndroidProjectService;
import com.google.appinventor.server.properties.json.ServerJsonParser;
import com.google.appinventor.server.storage.StorageIo;
import com.google.appinventor.server.storage.StorageIoInstanceHolder;
import com.google.appinventor.server.util.CsvParser;

import com.google.appinventor.shared.properties.json.JSONArray;
import com.google.appinventor.shared.properties.json.JSONObject;
import com.google.appinventor.shared.properties.json.JSONValue;
import com.google.appinventor.shared.rpc.BlocksTruncatedException;
import com.google.appinventor.shared.rpc.InvalidSessionException;
import com.google.appinventor.shared.rpc.RpcResult;
import com.google.appinventor.shared.rpc.project.ChecksumedFileException;
import com.google.appinventor.shared.rpc.project.ChecksumedLoadFile;
import com.google.appinventor.shared.rpc.project.FileDescriptor;
import com.google.appinventor.shared.rpc.project.FileDescriptorWithContent;
import com.google.appinventor.shared.rpc.project.NewProjectParameters;
import com.google.appinventor.shared.rpc.project.ProjectRootNode;
import com.google.appinventor.shared.rpc.project.ProjectService;
import com.google.appinventor.shared.rpc.project.TextFile;
import com.google.appinventor.shared.rpc.project.UserProject;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidProjectNode;
import com.google.appinventor.shared.util.Base64Util;

import com.google.common.collect.Lists;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.json.JSONException;

/**
 * The implementation of the RPC service which runs on the server.
 *
 * Note that this service must be state-less so that it can be run on
 * multiple servers.
 *
 */

<span class="fc" id="L63">public class ProjectServiceImpl extends OdeRemoteServiceServlet implements ProjectService {</span>

<span class="fc" id="L65">  private static final Logger LOG = Logger.getLogger(ProjectServiceImpl.class.getName());</span>

  private static final long serialVersionUID = -8316312003804169166L;

<span class="fc" id="L69">  private final transient StorageIo storageIo = StorageIoInstanceHolder.getInstance();</span>

  // RPC implementation for YoungAndroid projects
<span class="fc" id="L72">  private final transient YoungAndroidProjectService youngAndroidProject =</span>
      new YoungAndroidProjectService(storageIo);

<span class="fc" id="L75">  private static final boolean DEBUG = Flag.createFlag(&quot;appinventor.debugging&quot;, false).get();</span>

  /**
   * Creates a new project.
   * @param projectType  type of new project
   * @param projectName  name of new project
   * @param params  optional parameter (project type dependent)
   *
   * @return  a {@link UserProject} for new project
   */
  @Override
  public UserProject newProject(String projectType, String projectName,
                                NewProjectParameters params) {
<span class="fc" id="L88">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L89">    long projectId = getProjectRpcImpl(userId, projectType).</span>
<span class="fc" id="L90">        newProject(userId, projectName, params);</span>
<span class="fc" id="L91">    return makeUserProject(userId, projectId);</span>
  }

  /**
   * Creates a new project from a zip file that is already stored
   *  on the server.
   * @param projectName  name of new project
   * @param pathToZip path the to template's zip file
   *
   * @return  a {@link UserProject} for new project
   */
  @Override
  public UserProject newProjectFromTemplate(String projectName, String pathToZip) {

    //Window.alert(&quot;newProjectFromTemplate &quot; + host + pathToZip);
    //   System.out.println(&quot;newProjectFromTemplate = &quot; +  host + pathToZip);
<span class="nc" id="L107">    UserProject userProject = null;</span>
    try {
<span class="nc" id="L109">      FileInputStream fis = new FileInputStream(pathToZip);</span>
<span class="nc" id="L110">      FileImporter fileImporter = new FileImporterImpl();</span>
<span class="nc" id="L111">      userProject = fileImporter.importProject(userInfoProvider.getUserId(), projectName, fis);</span>
<span class="nc" id="L112">    } catch (IOException e) {</span>
<span class="nc" id="L113">      LOG.log(Level.SEVERE, &quot;I/O Error importing from template project&quot;, e);</span>
<span class="nc" id="L114">    } catch (FileImporterException e) {</span>
<span class="nc" id="L115">      LOG.log(Level.SEVERE, &quot;FileImporterException Error importing from template project&quot;, e);</span>
<span class="nc" id="L116">    }</span>

<span class="nc" id="L118">    return userProject;</span>
  }

  /**
   * This service is passed a base64 encoded string representing the Zip file.
   * It converts it to a byte array and imports the project using FileImporter.
   *
   * @see http://stackoverflow.com/questions/6409587/
   *   generating-an-inline-image-with-java-gwt/6495356#6495356
   */
  @Override
  public UserProject newProjectFromExternalTemplate(String projectName, String zipData) {

<span class="nc" id="L131">    System.out.println(&quot;&gt;&gt;&gt;&gt;&gt; ProjectService newProjectFromExternalTemplate name = &quot; + projectName);</span>
<span class="nc" id="L132">    UserProject userProject = null;</span>

    // Convert base64 string to byte[]
    // NOTE: GWT's Base64Utils uses a non-standard algorithm.
    // @see:  https://code.google.com/p/google-web-toolkit/issues/detail?id=3880
<span class="nc" id="L137">    byte[] binData = null;</span>
<span class="nc" id="L138">    binData = Base64Util.decodeLines(zipData);</span>

    // Import the project
<span class="nc" id="L141">    ByteArrayInputStream bais = null;</span>
<span class="nc" id="L142">    FileImporter fileImporter = new FileImporterImpl();</span>
    try {
<span class="nc" id="L144">      bais = new ByteArrayInputStream(binData);</span>
<span class="nc" id="L145">      userProject = fileImporter.importProject(userInfoProvider.getUserId(),</span>
        projectName, bais);
<span class="nc" id="L147">    } catch (FileNotFoundException e) {  // Create a new empty project if no Zip</span>
<span class="nc" id="L148">      LOG.log(Level.SEVERE, &quot;File Not Found importing from template project (external)&quot;, e);</span>
<span class="nc" id="L149">    } catch (IOException e) {</span>
<span class="nc" id="L150">      LOG.log(Level.SEVERE, &quot;I/O Error importing from template project (external)&quot;, e);</span>
<span class="nc" id="L151">    } catch (FileImporterException e) {</span>
<span class="nc" id="L152">      LOG.log(Level.SEVERE, &quot;FileImporterException Error importing from template project (external)&quot;, e);</span>
<span class="nc" id="L153">    }</span>
<span class="nc" id="L154">    return userProject;</span>
  }


  /**
   * Reads the template data from a JSON File
   * @param pathToTemplatesDir pathname of the templates directory which may contain
   *  0 or more template instances, each of which consists of a JSON file describing
   *  the template, plus a zip file and image files.
   *
   * @return A json-formatted String consisting of an array of template objects
   */
  @Override
  public String retrieveTemplateData(String pathToTemplatesDir) {
<span class="nc" id="L168">    String json = &quot;[&quot;;</span>
<span class="nc" id="L169">    File templatesRepository = new File(pathToTemplatesDir);</span>
<span class="nc" id="L170">    File templateFolder[] = templatesRepository.listFiles();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    for (File file: templateFolder) {</span>
<span class="nc" id="L172">      String templateName = file.getName();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (file.isDirectory()) {  // Should be a template folder</span>
<span class="nc" id="L174">        File templateFiles[] = file.listFiles();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (File f: templateFiles) {</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">          if (f.isFile() &amp;&amp; f.getName().equals(templateName + &quot;.json&quot;)) {</span>
            try {
<span class="nc" id="L178">              BufferedReader in = new BufferedReader(</span>
                new FileReader(pathToTemplatesDir + &quot;/&quot; + templateName + &quot;/&quot; + templateName + &quot;.json&quot;));
<span class="nc" id="L180">              json += in.readLine() +  &quot;, &quot;;</span>
<span class="nc" id="L181">            } catch (IOException e) {</span>
<span class="nc" id="L182">              LOG.log(Level.SEVERE, &quot;I/O Exception reading template json file: &quot; + templateName, e);</span>
<span class="nc" id="L183">              throw CrashReport.createAndLogError(LOG, getThreadLocalRequest(), null,</span>
                new IllegalArgumentException(&quot;Cannot Read Internal Project Template&quot;));
<span class="nc" id="L185">            }</span>
          }
        }
      }
    }
<span class="nc" id="L190">    return json + &quot;]&quot;;</span>
  }

  /**
   * Copies a project with a new name.
   * @param oldProjectId  old project ID
   * @param newName new project name
   *
   * @return  a {@link UserProject} for new project
   */
  @Override
  public UserProject copyProject(long oldProjectId, String newName){
<span class="fc" id="L202">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L203">    long projectId = getProjectRpcImpl(userId, oldProjectId).</span>
<span class="fc" id="L204">        copyProject(userId, oldProjectId, newName);</span>
<span class="fc" id="L205">    return makeUserProject(userId, projectId);</span>
  }

  /**
   * Deletes a project.
   * @param projectId  project ID
   */
  @Override
  public void deleteProject(long projectId) {
<span class="fc" id="L214">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L215">    getProjectRpcImpl(userId, projectId).deleteProject(userId, projectId);</span>
<span class="fc" id="L216">  }</span>

  /**
   * Moves the project to trash.
   * @param projectId  project ID
   */
  @Override
  public UserProject moveToTrash(long projectId) {
<span class="nc" id="L224">      String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L225">      storageIo.setMoveToTrashFlag(userId,projectId,true);</span>
<span class="nc" id="L226">      return storageIo.getUserProject(userId,projectId);</span>
  }

  /**
   * Moves the project back to My Projects Tab.
   * @param projectId  project ID
   */
  @Override
  public UserProject restoreProject(long projectId) {
<span class="nc" id="L235">      String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L236">      storageIo.setMoveToTrashFlag(userId,projectId,false);</span>
<span class="nc" id="L237">      return storageIo.getUserProject(userId,projectId);</span>
  }

  /**
   * Login to the new Gallery
   *
   * Generate a token used to login to the new gallery
   * @return RPC Result which contains URL to open a window on the Gallery
   */

  @Override
  public RpcResult loginToGallery() {
<span class="nc" id="L249">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L250">    return youngAndroidProject.loginToGallery(userId);</span>
  }

  /**
   * Send project to new Gallery
   * @param projectId project ID
   * @return RPC Result which contains URL to open a window on the Gallery
   */

  @Override
  public RpcResult sendToGallery(long projectId) {
<span class="nc" id="L261">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L262">    return getProjectRpcImpl(userId, projectId).sendToGallery(userId, projectId);</span>
  }

  /**
   * Load a project from the Gallery
   * We take the galleryId, fetch the project from the (remote) Gallery
   * store it with the user's projects and return a UserProject object
   * to the client, which will then load the project into the UI
   * @param galleryId The unique id for the project in the gallery
   * @return UserProject Info for the UI to load the project
   *
   * Note: The server loads the project directly from the gallery
   *       it is *not* routed via the user's browser
   *
   */

  @Override
  public UserProject loadFromGallery(String galleryId) throws IOException {
<span class="nc" id="L280">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L281">    return getProjectRpcImpl(userId,</span>
<span class="nc" id="L282">      YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE).loadFromGallery(userId, galleryId);</span>
  }

  /**
   * Returns an array with project IDs.
   *
   * @return  IDs of projects found by the back-end
   */
  @Override
  public long[] getProjects() {
<span class="fc" id="L292">    List&lt;Long&gt; projects = storageIo.getProjects(userInfoProvider.getUserId());</span>
<span class="fc" id="L293">    long[] projectIds = new long[projects.size()];</span>
<span class="fc" id="L294">    int i = 0;</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    for (Long project : projects) {</span>
<span class="fc" id="L296">      projectIds[i++] = project;</span>
<span class="fc" id="L297">    }</span>
<span class="fc" id="L298">    return projectIds;</span>
  }

  /**
   * Returns a list with pairs of project id and name.
   *
   * @return list of pairs of project IDs names found by backend
   */
  @Override
  public List&lt;UserProject&gt; getProjectInfos() {
<span class="fc" id="L308">    String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L309">    List&lt;Long&gt; projectIds = storageIo.getProjects(userId);</span>
<span class="fc" id="L310">    return makeUserProjects(userId, projectIds);</span>
  }

  /**
   * Returns the root node for the given project.
   * @param projectId  project ID as received by {@link #getProjects()}
   *
   * @return  root node of project
   */
  @Override
  public ProjectRootNode getProject(long projectId) {
<span class="fc" id="L321">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L322">    return getProjectRpcImpl(userId, projectId).getRootNode(userId, projectId);</span>
  }

  /**
   * Returns a string with the project settings.
   * @param projectId  project ID
   *
   * @return  settings
   */
  @Override
  public String loadProjectSettings(long projectId) {
<span class="fc" id="L333">    String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L334">    return storageIo.loadProjectSettings(userId, projectId);</span>
  }

  /**
   * Stores a string with the project settings.
   * @param sessionId session id
   * @param projectId  project ID
   * @param settings  project settings
   */
  @Override
  public void storeProjectSettings(String sessionId, long projectId, String settings) throws InvalidSessionException {
<span class="fc" id="L345">    validateSessionId(sessionId);</span>
<span class="fc" id="L346">    String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L347">    getProjectRpcImpl(userId, projectId).storeProjectSettings(userId, projectId, settings);</span>
<span class="fc" id="L348">  }</span>

  /**
   * Deletes a file in the given project.
   * @param sessionId session id
   * @param projectId  project ID
   * @param fileId  ID of file to delete
   * @return modification date for project
   */
  @Override
  public long deleteFile(String sessionId, long projectId, String fileId) throws InvalidSessionException {
<span class="fc" id="L359">    validateSessionId(sessionId);</span>
<span class="fc" id="L360">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L361">    return getProjectRpcImpl(userId, projectId).deleteFile(userId, projectId, fileId);</span>
  }

  /**
   * Deletes all files that are contained directly in the given directory. Files
   * in subdirectories are not deleted.
   * @param sessionId session id
   * @param projectId project ID
   * @param directory path of the directory
   * @return modification date for project
   */
  @Override
  public long deleteFiles(String sessionId, long projectId, String directory) throws InvalidSessionException {
<span class="nc" id="L374">    validateSessionId(sessionId);</span>
<span class="nc" id="L375">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L376">    return getProjectRpcImpl(userId, projectId).deleteFiles(userId, projectId,</span>
            directory);
  }

    /**
     * Deletes all files and folders that are contained inside the given directory. The given directory itself is deleted.
     * @param sessionId session id
     * @param projectId project ID
     * @param directory path of the directory
     * @return modification date for project
     */
  @Override
  public long deleteFolder(String sessionId, long projectId, String directory) throws InvalidSessionException {
<span class="nc" id="L389">      validateSessionId(sessionId);</span>
<span class="nc" id="L390">      final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L391">      return getProjectRpcImpl(userId, projectId).deleteFolder(userId, projectId,</span>
              directory);
  }

  /**
   * Loads the file information associated with a node in the project tree. The
   * actual return value depends on the file kind. Source (text) files should
   * typically return their contents. Image files will be more likely to return
   * the URL that the browser can find them at.
   *
   * @param projectId  project ID
   * @param fileId  project node whose source should be loaded
   *
   * @return  implementation dependent
   */
  @Override
  public String load(long projectId, String fileId) {
<span class="fc" id="L408">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L409">    return getProjectRpcImpl(userId, projectId).load(userId, projectId, fileId);</span>
  }

  /**
   * Loads the file information associated with a node in the project tree. After
   * loading the file, the contents of it are parsed.
   *
   * &lt;p&gt;Expected format is either JSON or CSV. If the first character of the
   * file's contents is a left curly bracket ( { ), then JSON parsing is
   * attempted. Otherwise, CSV parsing is done.
   *
   * @param projectId  project ID
   * @param fileId  project node whose source should be loaded
   *
   * @return  List of parsed columns (each column is a List of Strings)
   */
  @Override
  public List&lt;List&lt;String&gt;&gt; loadDataFile(long projectId, String fileId) {
<span class="nc" id="L427">    final int maxRows = 10; // Parse a maximum of 10 rows</span>

    // Load the contents of the specified file
<span class="nc" id="L430">    String result = load(projectId, fileId);</span>

    // If the contents of the file start with a curly bracket, assume JSON
    // and attempt parsing the contents as JSON. Otherwise, attempt to parse
    // the contents as a CSV file.
<span class="nc bnc" id="L435" title="All 2 branches missed.">    if (result.startsWith(&quot;{&quot;)) {</span>
      try {
<span class="nc" id="L437">        return parseJsonColumns(result, maxRows);</span>
<span class="nc" id="L438">      } catch (JSONException e) {</span>
        // JSON parsing failed; Attempt CSV parsing instead
<span class="nc" id="L440">        return parseCsvColumns(result, maxRows);</span>
      }
    } else {
<span class="nc" id="L443">      return parseCsvColumns(result, maxRows);</span>
    }
  }

  /**
   * Parses and returns columns from the specified String formatted
   * in CSV.
   *
   * @param source  Source String to parse CSV columns from
   * @param rows  Number of rows to parse
   * @return  List representing the columns (each column is a List of Strings)
   */
  private List&lt;List&lt;String&gt;&gt; parseCsvColumns(String source, int rows) {
<span class="nc" id="L456">    List&lt;List&lt;String&gt;&gt; columns = new ArrayList&lt;List&lt;String&gt;&gt;();</span>

    // Construct an InputStream and a CSVParser for the contents of the file
<span class="nc" id="L459">    ByteArrayInputStream inputStream = new ByteArrayInputStream(source.getBytes());</span>
<span class="nc" id="L460">    CsvParser csvParser = new CsvParser(inputStream);</span>

<span class="nc bnc" id="L462" title="All 4 branches missed.">    for (int i = 0; i &lt;= rows &amp;&amp; csvParser.hasNext(); ++i) {</span>
      // Parse next row
<span class="nc" id="L464">      List&lt;String&gt; row = csvParser.next();</span>

      // Add row entries to columns
<span class="nc bnc" id="L467" title="All 2 branches missed.">      for (int j = 0; j &lt; row.size(); ++j) {</span>
        // A List for the column did not exist before; Create one
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (columns.size() &lt;= j) {</span>
<span class="nc" id="L470">          columns.add(new ArrayList&lt;String&gt;());</span>
        }

        // Add the j-th element of the row to the j-th column.
        // E.G. consider the CSV row 1,2,3,4
        // 1 goes into the 1st column, 2 goes into the 2nd one, and so on.
        // So the indexes for both the column and the row match.
<span class="nc" id="L477">        columns.get(j).add(row.get(j));</span>
      }
    }

<span class="nc" id="L481">    return columns;</span>
  }

  /**
   * Parses and returns columns from the specified String formatted
   * in JSON.
   *
   * @param source  Source String to parse JSON columns from
   * @param rows  Number of rows to parse
   * @return  List representing the columns (each column is a List of Strings)
   */
  private List&lt;List&lt;String&gt;&gt; parseJsonColumns(String source, int rows) throws JSONException {
<span class="nc" id="L493">    List&lt;List&lt;String&gt;&gt; columns = new ArrayList&lt;List&lt;String&gt;&gt;();</span>

    // Parse a JSON value from the specified source String
<span class="nc" id="L496">    ServerJsonParser jsonParser = new ServerJsonParser();</span>
<span class="nc" id="L497">    JSONValue value = jsonParser.parse(source);</span>

    // Value must be a JSONObject for the parsing to be valid. If
    // that is not the case, skip column parsing.
<span class="nc bnc" id="L501" title="All 2 branches missed.">    if (value instanceof JSONObject) {</span>
      // Get the value as a JSONObject and retrieve the properties (key-value pairs)
<span class="nc" id="L503">      Map&lt;String, JSONValue&gt; properties = value.asObject().getProperties();</span>

      // Iterate over all the entries (one entry is interpreted as a single column)
<span class="nc bnc" id="L506" title="All 2 branches missed.">      for (final Map.Entry&lt;String, JSONValue&gt; entry : properties.entrySet()) {</span>
<span class="nc" id="L507">        List&lt;String&gt; column = new ArrayList&lt;String&gt;();</span>

        // Add the key as the first entry in the column
<span class="nc" id="L510">        column.add(entry.getKey());</span>

        // Get the actual value of the column
<span class="nc" id="L513">        JSONValue entryValue = entry.getValue();</span>

        // JSONArrays require different handling
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (entryValue instanceof JSONArray) {</span>
          // Retrieve the value as an Array, and get it's elements
<span class="nc" id="L518">          JSONArray entryArray = entryValue.asArray();</span>
<span class="nc" id="L519">          List&lt;JSONValue&gt; jsonElements = entryArray.getElements();</span>

          // A maximum of the specified rows should be parsed.
<span class="nc" id="L522">          int entries = Math.min(jsonElements.size(), rows);</span>

          // Add all the entries from the array to the column
<span class="nc bnc" id="L525" title="All 2 branches missed.">          for (int i = 0; i &lt; entries; ++i) {</span>
<span class="nc" id="L526">            JSONValue arrayValue = jsonElements.get(i);</span>
<span class="nc" id="L527">            column.add(arrayValue.toString()); // Value has to be converted to String</span>
          }
<span class="nc" id="L529">        } else {</span>
          // Add the value as a String to the elements of the column
<span class="nc" id="L531">          column.add(entryValue.toString());</span>
        }

        // Add the constructed column to the resulting columns List
<span class="nc" id="L535">        columns.add(column);</span>
<span class="nc" id="L536">      }</span>
    }

<span class="nc" id="L539">    return columns;</span>
  }

  /**
   * Loads the file information associated with a node in the project tree. The
   * actual return value depends on the file kind. Source (text) files should
   * typically return their contents. Image files will be more likely to return
   * the URL that the browser can find them at.
   *
   * This version returns a ChecksumedLoadFile which contains the file content
   * and a MD5 checksum.
   *
   * @param projectId  project ID
   * @param fileId  project node whose source should be loaded
   *
   * @return  implementation dependent
   */
  @Override
  public ChecksumedLoadFile load2(long projectId, String fileId) throws ChecksumedFileException {
<span class="nc" id="L558">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L559">    return getProjectRpcImpl(userId, projectId).load2(userId, projectId, fileId);</span>
  }

  /**
   * Attempt to record the project Id and error message when we detect a corruption
   * while loading a project.
   *
   * @param projectId project id
   * @param message Error message from the thrown exception
   *
   */
  @Override
  public void recordCorruption(long projectId, String fileId, String message) {
<span class="nc" id="L572">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L573">    getProjectRpcImpl(userId, projectId).recordCorruption(userId, projectId, fileId, message);</span>
<span class="nc" id="L574">  }</span>

  /**
   * Loads the file information associated with a node in the project tree. The
   * actual return value is the raw file contents.
   *
   * @param projectId  project ID
   * @param fileId  project node whose source should be loaded
   *
   * @return  raw file content
   */
  @Override
  public byte [] loadraw(long projectId, String fileId) {
<span class="nc" id="L587">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L588">    return getProjectRpcImpl(userId, projectId).loadraw(userId, projectId, fileId);</span>
  }

  /**
   * Loads the file information associated with a node in the project tree. The
   * actual return value is the raw file contents encoded as base64.
   *
   * @param projectId  project ID
   * @param fileId  project node whose source should be loaded
   *
   * @return  raw file content as base 64
   */
  @Override
  public String loadraw2(long projectId, String fileId) {
<span class="nc" id="L602">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L603">    return getProjectRpcImpl(userId, projectId).loadraw2(userId, projectId, fileId);</span>
  }

  /**
   * Loads the contents of multiple files.
   *
   * @param files  list containing file descriptor of files to be loaded
   * @return  list containing file descriptors and their associated content
   */
  @Override
  public List&lt;FileDescriptorWithContent&gt; load(List&lt;FileDescriptor&gt; files) {
<span class="fc" id="L614">    List&lt;FileDescriptorWithContent&gt; result = Lists.newArrayList();</span>
<span class="fc" id="L615">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">    for (FileDescriptor file : files) {</span>
<span class="fc" id="L617">      long projectId = file.getProjectId();</span>
<span class="fc" id="L618">      String fileId = file.getFileId();</span>
<span class="fc" id="L619">      result.add(new FileDescriptorWithContent(</span>
          projectId, fileId,
<span class="fc" id="L621">          getProjectRpcImpl(userId, projectId).load(userId, projectId, fileId)));</span>
<span class="fc" id="L622">    }</span>
<span class="fc" id="L623">    return result;</span>
  }

  /**
   * Saves the content of the file associated with a node in the project tree.
   *
   * @param sessionId session id
   * @param projectId  project ID
   * @param fileId  project node whose source should be saved
   * @param content  content to be saved
   * @return modification date for project
   *
   * @see #load(long, String)
   */
  @Override
  public long save(String sessionId, long projectId, String fileId, String content) throws InvalidSessionException {
<span class="fc" id="L639">    validateSessionId(sessionId);</span>
    // Log parameters except for content
<span class="fc" id="L641">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L642">    return getProjectRpcImpl(userId, projectId).save(userId, projectId, fileId,</span>
        content);
  }

  /**
   * Saves the content of the file associated with a node in the project tree.
   * This version takes a &quot;force&quot; argument which if false will result in an
   * exception of a trivial (empty) blocks workspace is attempted to be saved
   *
   * @param sessionId session id
   * @param projectId  project ID
   * @param fileId  project node whose source should be saved
   * @param force whether to write an empty blocks workspace
   * @param content  content to be saved
   * @return modification date for project
   *
   * @see #load(long, String)
   */
  @Override
  public long save2(String sessionId, long projectId, String fileId, boolean force, String content) throws InvalidSessionException,
      BlocksTruncatedException {
<span class="nc" id="L663">    validateSessionId(sessionId);</span>
    // Log parameters except for content
<span class="nc" id="L665">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L666">    return getProjectRpcImpl(userId, projectId).save2(userId, projectId, fileId, force,</span>
        content);
  }

  /**
   * Saves the contents of multiple files.
   *
   * @param sessionId session id
   * @param filesAndContent  list containing file descriptors and their
   *                         associated content
   * @return modification date for last modified project of list
   */
  @Override
  public long save(String sessionId, List&lt;FileDescriptorWithContent&gt; filesAndContent) throws InvalidSessionException,
      BlocksTruncatedException {
<span class="fc" id="L681">    validateSessionId(sessionId);</span>
<span class="fc" id="L682">    final String userId = userInfoProvider.getUserId();</span>
<span class="fc" id="L683">    long date = 0;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">    for (FileDescriptorWithContent fileAndContent : filesAndContent) {</span>
<span class="fc" id="L685">     long projectId = fileAndContent.getProjectId();</span>
<span class="fc" id="L686">     date = getProjectRpcImpl(userId, projectId).</span>
<span class="fc" id="L687">         save(userId, projectId, fileAndContent.getFileId(), fileAndContent.getContent());</span>
<span class="fc" id="L688">    }</span>
<span class="fc" id="L689">    return date;</span>
  }

  @Override
  public RpcResult screenshot(String sessionId, long projectId, String fileId, String content)
    throws InvalidSessionException {
<span class="nc" id="L695">    validateSessionId(sessionId);</span>
<span class="nc" id="L696">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L697">    return getProjectRpcImpl(userId, projectId).screenshot(userId, projectId, fileId,</span>
      content);
  }

  /**
   * Invokes a build command for the project on the back-end.
   *
   * @param projectId  project ID
   * @param target  build target (optional, implementation dependent)
   *
   * @return  results of build
   */
  @Override
  public RpcResult build(long projectId, String nonce, String target, boolean secondBuildserver, boolean isAab) {
    // Dispatch
<span class="nc" id="L712">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L713">    return getProjectRpcImpl(userId, projectId).build(</span>
<span class="nc" id="L714">      userInfoProvider.getUser(), projectId, nonce, target, secondBuildserver, isAab);</span>
  }

  /**
   * Gets the result of a build command for the project.
   *
   * @param projectId  project ID
   * @param target  build target (optional, implementation dependent)
   *
   * @return  results of build. The following values may be in RpcResult.result:
   *            0: Build is done and was successful
   *            1: Build is done and was unsuccessful
   *           -1: Build is not yet done.
   */
  @Override
  public RpcResult getBuildResult(long projectId, String target) {
    // Dispatch
<span class="nc" id="L731">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L732">    return getProjectRpcImpl(userId, projectId).getBuildResult(</span>
<span class="nc" id="L733">      userInfoProvider.getUser(), projectId, target);</span>
  }

  /*
   * Write the serialized response out to stdout. This is a very unusual thing
   * to do, but it allows us to create a static file version of the response
   * without deploying a servlet.
   *
   * Commented out by JIS 11/12/13
   */
  @Override
  protected void onAfterResponseSerialized(String serializedResponse) {
    // System.out.println(serializedResponse);  // COV_NF_LINE
<span class="nc" id="L746">  }</span>

  private UserProject makeUserProject(String userId, long projectId) {
<span class="fc" id="L749">    return storageIo.getUserProject(userId, projectId);</span>
  }

  // Bulk fetch UserProjects -- efficiently get all project infos asked for
  // using a minimum number of datastore API calls
  private List&lt;UserProject&gt; makeUserProjects(String userId, List&lt;Long&gt; projectIds) {
<span class="fc" id="L755">    return storageIo.getUserProjects(userId, projectIds);</span>
  }

  /*
   * Returns the RPC implementation for the given project type.
   */
  private CommonProjectService getProjectRpcImpl(final String userId, long projectId) {
<span class="fc" id="L762">    String projectType = storageIo.getProjectType(userId, projectId);</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">    if (!projectType.isEmpty()) {</span>
<span class="fc" id="L764">      return getProjectRpcImpl(userId, projectType);</span>
    } else {
<span class="nc" id="L766">      throw CrashReport.createAndLogError(LOG, getThreadLocalRequest(),</span>
          &quot;user=&quot; + userId + &quot;, project=&quot; + projectId,
          new IllegalArgumentException(&quot;Can't find project &quot; + projectId));
    }
  }

  private CommonProjectService getProjectRpcImpl(final String userId, String projectType) {
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">    if (projectType.equals(YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE)) {</span>
<span class="fc" id="L774">      return youngAndroidProject;</span>
    } else {
<span class="nc" id="L776">      throw CrashReport.createAndLogError(LOG, getThreadLocalRequest(), null,</span>
          new IllegalArgumentException(&quot;Unknown project type:&quot; + projectType));
    }
  }

  @Override
  public long addFile(long projectId, String fileId) {
<span class="nc" id="L783">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L784">    return getProjectRpcImpl(userId, projectId).addFile(userId, projectId, fileId);</span>
  }

  @Override
  public TextFile importMedia(String sessionId, long projectId, String url, boolean save)
      throws InvalidSessionException, IOException {
<span class="nc" id="L790">    validateSessionId(sessionId);</span>
<span class="nc" id="L791">    final String userId = userInfoProvider.getUserId();</span>
<span class="nc" id="L792">    return getProjectRpcImpl(userId, projectId).importMedia(userId, projectId, url, save);</span>
  }

  @Override
  public void log(String message) {
<span class="nc" id="L797">    LOG.warning(message);</span>
<span class="nc" id="L798">  }</span>

  private void validateSessionId(String sessionId) throws InvalidSessionException {
<span class="fc" id="L801">    String storedSessionId = userInfoProvider.getSessionId();</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">    if (DEBUG) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">      if (storedSessionId == null) {</span>
<span class="nc" id="L804">        LOG.info(&quot;storedSessionId is null&quot;);</span>
      } else {
<span class="nc" id="L806">        LOG.info(&quot;storedSessionId = &quot; + storedSessionId);</span>
      }
    }
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">    if (sessionId.equals(&quot;force&quot;)) { // If we are forcing our way -- no check</span>
<span class="nc" id="L810">      return;</span>
    }
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">    if (!storedSessionId.equals(sessionId))</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">      if (AppInventorFeatures.requireOneLogin()) {</span>
<span class="nc" id="L814">        throw new InvalidSessionException(&quot;A more recent login has occurred since we started. No further changes will be saved.&quot;);</span>
      }
<span class="fc" id="L816">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>