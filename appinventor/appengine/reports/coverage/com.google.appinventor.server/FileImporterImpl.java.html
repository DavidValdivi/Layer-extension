<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileImporterImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.server</a> &gt; <span class="el_source">FileImporterImpl.java</span></div><h1>FileImporterImpl.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2019 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.server;

import com.google.appinventor.common.utils.StringUtils;
import com.google.appinventor.server.flags.Flag;
import com.google.appinventor.server.project.youngandroid.YoungAndroidProjectService;
import com.google.appinventor.server.project.youngandroid.YoungAndroidSettingsBuilder;
import com.google.appinventor.server.storage.StorageIo;
import com.google.appinventor.server.storage.StorageIoInstanceHolder;
import com.google.appinventor.shared.rpc.UploadResponse;
import com.google.appinventor.shared.rpc.project.Project;
import com.google.appinventor.shared.rpc.project.RawFile;
import com.google.appinventor.shared.rpc.project.TextFile;
import com.google.appinventor.shared.rpc.project.UserProject;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidProjectNode;
import com.google.appinventor.shared.storage.StorageUtil;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.io.ByteStreams;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;

import javax.annotation.Nullable;

/**
 * Implementation of {@link FileImporter} based on {@link StorageIo}
 *
 * @author lizlooney@google.com (Liz Looney)
 */
<span class="fc" id="L48">public final class FileImporterImpl implements FileImporter {</span>

  // Maximum size of an uploaded asset, in megabytes.
<span class="fc" id="L51">  private static final Flag&lt;Float&gt; maxAssetSizeMegs = Flag.createFlag(&quot;max.asset.size.megs&quot;, 9f);</span>

<span class="fc" id="L53">  private static final Logger LOG = Logger.getLogger(FileImporterImpl.class.getName());</span>

<span class="fc" id="L55">  private final StorageIo storageIo = StorageIoInstanceHolder.getInstance();</span>

  @Override
  public UserProject importProject(String userId, String projectName,
      InputStream uploadedFileStream) throws FileImporterException, IOException {
<span class="fc" id="L60">    return importProject(userId, projectName, uploadedFileStream, null);</span>
  }

  @Override
  public UserProject importProject(String userId, String projectName,
                                   InputStream uploadedFileStream, @Nullable String projectHistory)
      throws FileImporterException, IOException {
    // The projectName parameter has already been validated, including checking for an
    // existing project with the same name. (See TextValidators.checkNewProjectName).

    // Begin creating the project.
<span class="fc" id="L71">    Project project = new Project(projectName);</span>
<span class="fc" id="L72">    project.setProjectType(YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE);</span>

    // As we process the ZipEntry for each file, we'll adjust the directory structure so that it is
    // appropriate for this user.
    // Here we get the information (such as the qualified form name) that we'll need to do that.
<span class="fc" id="L77">    String qualifiedFormName = StringUtils.getQualifiedFormName(</span>
<span class="fc" id="L78">        storageIo.getUser(userId).getUserEmail(), projectName);</span>
<span class="fc" id="L79">    String srcDirectory = YoungAndroidProjectService.getSourceDirectory(qualifiedFormName);</span>

<span class="fc" id="L81">    ZipInputStream zin = new ZipInputStream(uploadedFileStream);</span>
<span class="fc" id="L82">    boolean isProjectArchive = false;  // have we found at least one project properties file?</span>
    try {
      // Extract files
      while (true) {
        ZipEntry entry;
        try {
<span class="fc" id="L88">          entry = zin.getNextEntry();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">          if (entry == null) {</span>
<span class="fc" id="L90">            break;</span>
          }
<span class="nc" id="L92">        } catch (ZipException e) {</span>
          // The uploaded file is not a valid zip file
<span class="nc" id="L94">          LOG.log(Level.SEVERE, &quot;Invalid Project Archive Format&quot;, e);</span>
<span class="nc" id="L95">          throw new FileImporterException(UploadResponse.Status.NOT_PROJECT_ARCHIVE);</span>
<span class="fc" id="L96">        }</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (!entry.isDirectory()) {</span>
<span class="fc" id="L99">          String fileName = entry.getName();</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">          if (fileName.equals(YoungAndroidProjectService.PROJECT_PROPERTIES_FILE_NAME)) {</span>
            // The content for the youngandroidproject/project.properties file must be regenerated
            // so that it contains the correct entries for &quot;main&quot; and &quot;name&quot;, which are dependent on
            // the projectName and qualifiedFormName.
<span class="fc" id="L105">            String content = new YoungAndroidSettingsBuilder()</span>
<span class="fc" id="L106">                .setProjectName(projectName)</span>
<span class="fc" id="L107">                .setQualifiedFormName(qualifiedFormName)</span>
<span class="fc" id="L108">                .toProperties();</span>
<span class="fc" id="L109">            project.addTextFile(new TextFile(fileName, content));</span>
<span class="fc" id="L110">            isProjectArchive = true;</span>

<span class="pc bpc" id="L112" title="1 of 2 branches missed.">          } else if (fileName.equals(FileExporter.REMIX_INFORMATION_FILE_PATH) ||</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">              fileName.equals(StorageUtil.ANDROID_KEYSTORE_FILENAME)) {</span>
            // If the remix information file is present, we ignore it. In the past, a remix
            // information file was saved in the zip when project source was downloaded and
            // retrieved from the zip when it was uploaded. However, we no longer do that because
            // we don't have a way to verify that the contents of the remix information file is
            // accurate during the upload.
            // If a keystore file is present we ignore that too for now, since
            // we don't have per-project keystores. The only way to get such a
            // source zip at the moment is using the admin functionality to
            // download another user's project source.
<span class="nc" id="L123">            continue;</span>

          } else {

<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (fileName.startsWith(YoungAndroidProjectService.SRC_FOLDER)) {</span>
              // For files within the src folder, we need to update the directory that we put files
              // in. Adjust the fileName so that it corresponds to this project's package.
<span class="fc" id="L130">              fileName = srcDirectory + '/' + StorageUtil.basename(fileName);</span>
            }

            // Get the file content from the ZipEntry.
<span class="fc" id="L134">            ByteArrayOutputStream contentStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L135">            ByteStreams.copy(zin, contentStream);</span>

<span class="fc" id="L137">            project.addRawFile(new RawFile(fileName, contentStream.toByteArray()));</span>
          }
        }
<span class="fc" id="L140">      }</span>
    } finally {
<span class="fc" id="L142">      zin.close();</span>
    }

<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (!isProjectArchive) {</span>
      // The uploaded file seems to be a valid zip file, but it doesn't contain the project
      // properties file.
<span class="fc" id="L148">      throw new FileImporterException(UploadResponse.Status.NOT_PROJECT_ARCHIVE);</span>
    }

    // Set project history if provided
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (projectHistory != null) {</span>
<span class="fc" id="L153">      project.setProjectHistory(projectHistory);</span>
    }
<span class="fc" id="L155">    String settings = new YoungAndroidSettingsBuilder().build();</span>
<span class="fc" id="L156">    long projectId = storageIo.createProject(userId, project, settings);</span>
<span class="fc" id="L157">    return storageIo.getUserProject(userId, projectId);</span>
  }

  @VisibleForTesting
  public long importFile(String userId, long projectId, String fileName,
      InputStream uploadedFileStream) throws FileImporterException, IOException {
<span class="fc" id="L163">    int maxAssetSizeBytes = (int) (maxAssetSizeMegs.get() * 1024 * 1024);</span>
<span class="fc" id="L164">    int maxSizeBytes = Math.min(maxAssetSizeBytes, storageIo.getMaxJobSizeBytes());</span>

<span class="fc" id="L166">    BufferedInputStream bis = new BufferedInputStream(uploadedFileStream);</span>
<span class="fc" id="L167">    ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span class="fc" id="L168">    BufferedOutputStream bos = new BufferedOutputStream(os);</span>

    // Alledgedly since it is buffered, reading in units of one byte
    // should be as fast as many bytes, but we can always adjust this.
<span class="fc" id="L172">    int bytes = 0;</span>
<span class="fc" id="L173">    long fileLength = 0;</span>
<span class="fc" id="L174">    byte[] buffer = new byte[1];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">    while ((bytes = bis.read(buffer, 0, buffer.length)) != -1) {</span>
<span class="fc" id="L176">      bos.write(buffer, 0, bytes);</span>
<span class="fc" id="L177">      fileLength += bytes;</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">      if (fileLength &gt; maxSizeBytes) {</span>
        // Read the rest of the stream, but throw it away
        // and throw an error, so we do not consume memory storing
        // a large object
<span class="nc bnc" id="L182" title="All 2 branches missed.">        while((bytes = bis.read(buffer, 0, buffer.length)) != -1) {</span>
        }
<span class="nc" id="L184">        throw new FileImporterException(UploadResponse.Status.FILE_TOO_LARGE);</span>
      }
    }
<span class="fc" id="L187">    bos.flush();</span>

<span class="fc" id="L189">    byte[] content = os.toByteArray();</span>

    // If the file already exists, we will overwrite the content.
<span class="fc" id="L192">    List&lt;String&gt; sourceFiles = storageIo.getProjectSourceFiles(userId, projectId);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">    if (!sourceFiles.contains(fileName)) {</span>
<span class="fc" id="L194">      storageIo.addSourceFilesToProject(userId, projectId, false, fileName);</span>
    }
<span class="fc" id="L196">    return storageIo.uploadRawFileForce(projectId, fileName, userId, content);</span>
  }

  @Override
  public void importUserFile(String userId, String fileName, InputStream uploadedFileStream)
      throws IOException {
<span class="nc" id="L202">    byte[] content = ByteStreams.toByteArray(uploadedFileStream);</span>

    // If the file already exists, we will overwrite the content.
<span class="nc" id="L205">    List&lt;String&gt; userFiles = storageIo.getUserFiles(userId);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (!userFiles.contains(fileName)) {</span>
<span class="nc" id="L207">      storageIo.addFilesToUser(userId, fileName);</span>
    }
<span class="nc" id="L209">    storageIo.uploadRawUserFile(userId, fileName, content);</span>
<span class="nc" id="L210">  }</span>

  @Override
  public String importTempFile(InputStream inStream) throws IOException {
<span class="nc" id="L214">    return storageIo.uploadTempFile(ByteStreams.toByteArray(inStream));</span>
  }

  @Override
  public Set&lt;String&gt; getProjectNames(final String userId) {
<span class="nc" id="L219">    List&lt;Long&gt; projectIds = storageIo.getProjects(userId);</span>
<span class="nc" id="L220">    Iterable&lt;String&gt; names = Iterables.transform(projectIds, new Function&lt;Long, String&gt;() {</span>
      @Override
      public String apply(Long projectId) {
<span class="nc" id="L223">        return storageIo.getProjectName(userId, projectId);</span>
      }
    });
<span class="nc" id="L226">    return ImmutableSet.copyOf(names);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>