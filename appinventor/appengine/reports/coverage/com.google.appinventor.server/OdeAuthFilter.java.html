<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OdeAuthFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.server</a> &gt; <span class="el_source">OdeAuthFilter.java</span></div><h1>OdeAuthFilter.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2019 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.server;

import com.google.appinventor.server.cookieauth.CookieAuth;
import java.io.Serializable;

import com.google.appinventor.server.flags.Flag;

import com.google.appinventor.server.storage.StorageIo;
import com.google.appinventor.server.storage.StorageIoInstanceHolder;

import com.google.appinventor.shared.rpc.ServerLayout;
import com.google.appinventor.shared.rpc.user.User;

import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.io.PrintWriter;

import java.util.logging.Logger;
import java.util.logging.Level;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.keyczar.Crypter;
import org.keyczar.exceptions.KeyczarException;

import org.keyczar.util.Base64Coder;


/**
 * An authentication filter that uses Google Accounts for logged-in users.
 *
 * @author markf@google.com (Mark Friedman)
 */
@SuppressWarnings({&quot;ThrowableInstanceNeverThrown&quot;})
public class OdeAuthFilter implements Filter {

<span class="nc" id="L52">  public OdeAuthFilter() {}</span>

<span class="nc" id="L54">  private static final Logger LOG = Logger.getLogger(OdeAuthFilter.class.getName());</span>

<span class="nc" id="L56">  private static Crypter crypter = null; // accessed through getCrypter only</span>
<span class="nc" id="L57">  private static final Object crypterSync = new Object();</span>

<span class="nc" id="L59">  private final StorageIo storageIo = StorageIoInstanceHolder.getInstance();</span>

  // Whether this server should use a whitelist to determine who can
  // access it. Value is specified in the &lt;system-properties&gt; section
  // of appengine-web.xml.
  @VisibleForTesting
<span class="nc" id="L65">  static final Flag&lt;Boolean&gt; useWhitelist = Flag.createFlag(&quot;use.whitelist&quot;, false);</span>
<span class="nc" id="L66">  static final Flag&lt;String&gt; sessionKeyFile = Flag.createFlag(&quot;session.keyfile&quot;, &quot;WEB-INF/authkey&quot;);</span>
<span class="nc" id="L67">  static final Flag&lt;Integer&gt; idleTimeout = Flag.createFlag(&quot;session.idletimeout&quot;, 120);</span>
<span class="nc" id="L68">  static final Flag&lt;Integer&gt; renewTime = Flag.createFlag(&quot;session.renew&quot;, 30);</span>

<span class="nc" id="L70">  private final LocalUser localUser = LocalUser.getInstance();</span>
<span class="nc" id="L71">  private static final boolean DEBUG = Flag.createFlag(&quot;appinventor.debugging&quot;, false).get();</span>

  /**
   * Filters using Google Accounts
   */
  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
      throws IOException, ServletException {

<span class="nc bnc" id="L80" title="All 4 branches missed.">    if (!(request instanceof HttpServletRequest &amp;&amp; response instanceof HttpServletResponse)) {</span>
<span class="nc" id="L81">      throw new ServletException(&quot;Unsupported request type.&quot;);</span>
    }

<span class="nc" id="L84">    final HttpServletRequest httpRequest = (HttpServletRequest) request;</span>
<span class="nc" id="L85">    final HttpServletResponse httpResponse = (HttpServletResponse) response;</span>

    // Use Local Authentication
    // String userid = (String) httpRequest.getSession().getAttribute(&quot;userid&quot;);
    // Object isReadOnlyObject = httpRequest.getSession().getAttribute(&quot;readonly&quot;);
    // boolean isReadOnly = false;
    // if (isReadOnlyObject != null) {
    //   isReadOnly = (boolean) isReadOnlyObject;
    // }
    // LOG.info(&quot;isReadOnly = &quot; + isReadOnly);
    // if (userid == null) {        // Invalid Login
    //   LOG.info(&quot;userid is null on login.&quot;);
    //   httpResponse.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
    //   return;
    // }

    // Use Local Authentication
<span class="nc" id="L102">    UserInfo userInfo = getUserInfo(httpRequest);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">    if (userInfo == null) {        // Invalid Login</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L105">        LOG.info(&quot;uinfo is null on login.&quot;);</span>
      }
      // If the URI starts with /ode, then we are being invoked through
      // the App Inventor client. In that case we are in an XMLHttpRequest
      // (aka ajax) so we cannot send a redirect to the login page
      // instead we return SC_PRECONDITION_FAILED which tips off the
      // client that it needs to reload itself to the login page.
<span class="nc" id="L112">      String uri = httpRequest.getRequestURI();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (DEBUG) {</span>
<span class="nc" id="L114">        LOG.info(&quot;Not Logged In: uri = &quot; + uri);</span>
      }
<span class="nc bnc" id="L116" title="All 2 branches missed.">      if (uri.startsWith(&quot;/ode&quot;)) {</span>
<span class="nc" id="L117">        httpResponse.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);</span>
      } else {
<span class="nc" id="L119">        httpResponse.sendRedirect(&quot;/login?redirect=&quot; + uri);</span>
      }
<span class="nc" id="L121">      return;</span>
    }

<span class="nc" id="L124">    String userId = userInfo.userId;</span>
<span class="nc" id="L125">    boolean isAdmin = userInfo.isAdmin;</span>
<span class="nc" id="L126">    boolean isReadOnly = userInfo.isReadOnly;</span>

//    Object oIsAdmin = httpRequest.getSession().getAttribute(&quot;isadmin&quot;);
//    if (oIsAdmin != null) {
//      isAdmin = (boolean) oIsAdmin;
//    }

<span class="nc" id="L133">    doMyFilter(userInfo, isAdmin, isReadOnly, httpRequest, httpResponse, chain);</span>
<span class="nc" id="L134">  }</span>

  @VisibleForTesting
  void doMyFilter(UserInfo userInfo, boolean isAdmin, boolean isReadOnly,
    HttpServletRequest request, HttpServletResponse response, FilterChain chain)
    throws IOException, ServletException {

    // Setup the user object for OdeRemoteServiceServlet
<span class="nc" id="L142">    setUserFromUserId(userInfo.userId, isAdmin, isReadOnly);</span>

    // If using local login, we *must* have an email address because that is how we
    // find the UserData object.
<span class="nc" id="L146">    String lemail = localUser.getUserEmail();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (lemail.equals(&quot;&quot;)) {</span>
      // We send a SC_PRECONDITION_FAILED which will cause the login page to
      // be displayed (or the use of Google Authentication if that is the only
      // mechanism enabled). This should *not* happen in production. However
      // it happens all the time in development when people do an &quot;ant clean&quot;
      // followed by an &quot;ant&quot;. This results in their development datastore being
      // erased. But their browser still contains a valid authentication cookie,
      // but the userId no longer exists. It is then automatically created
      // in code called before here, but the e-mail address is not set. So
      // we error out here.
<span class="nc" id="L157">      response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);</span>
<span class="nc" id="L158">      return;</span>
    }

    try {
<span class="nc bnc" id="L162" title="All 4 branches missed.">      if (useWhitelist.get() &amp;&amp; !isUserWhitelisted()) {</span>
<span class="nc" id="L163">        writeWhitelistErrorMessage(response);</span>
        // This indicates to the client side code that the user is not on the whitelist.
<span class="nc" id="L165">        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span>
<span class="nc" id="L166">        return;  // This blocks further processing of the request.</span>
      }
      // If user hasn't accepted terms of service, redirect them,
      // unless they're submitting the acceptance request.
<span class="nc bnc" id="L170" title="All 4 branches missed.">      if (!localUser.getUserTosAccepted() &amp;&amp; !isReadOnly &amp;&amp;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">          !request.getRequestURI().endsWith(ServerLayout.ACCEPT_TOS_SERVLET)) {</span>
        // This indicates to the client side code that the user needs to accept
        // the terms of service. We don't send the redirect here because
        // it isn't understood properly by GWT RPC
<span class="nc" id="L175">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span>
<span class="nc" id="L176">        return;</span>
      }
<span class="nc" id="L178">      String newCookie = userInfo.buildCookie(true);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (newCookie != null) {  // If we get a value here, it is time to renew</span>
                                // the Cookie
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L182">          LOG.info(&quot;Renewing the authentication Cookie&quot;);</span>
        }
<span class="nc" id="L184">        Cookie cook = new Cookie(&quot;AppInventor&quot;, newCookie);</span>
<span class="nc" id="L185">        cook.setPath(&quot;/&quot;);</span>
<span class="nc" id="L186">        response.addCookie(cook);</span>
      }
<span class="nc" id="L188">      chain.doFilter(request, response);</span>
    } finally {
<span class="nc" id="L190">      removeUser();</span>
    }
<span class="nc" id="L192">  }</span>

  @VisibleForTesting
  boolean isUserWhitelisted() {
    //return whitelist.isInWhitelist(localUser);
<span class="nc" id="L197">    return storageIo.checkWhiteList(localUser.getUserEmail());</span>
  }

  @VisibleForTesting
  void writeWhitelistErrorMessage(HttpServletResponse response) throws IOException {
<span class="nc" id="L202">    response.setContentType(&quot;text/plain; charset=utf-8&quot;);</span>
<span class="nc" id="L203">    PrintWriter out = response.getWriter();</span>
<span class="nc" id="L204">    out.print(&quot;You are attempting to connect to this App Inventor service with the login ID:\n\n&quot; +</span>
<span class="nc" id="L205">        localUser.getUserEmail() + &quot;\n\nThat ID has not been authorized to use this service.  &quot; +</span>
        &quot;If you believe that you were in fact given authorization, you should contact the &quot; +
        &quot;service operator.&quot;);
<span class="nc" id="L208">  }</span>

  /*
   * Sets the user for the current thread according to the given userId.
   *
   * &lt;p&gt;This method is called from {@link WebStartFileServlet} with the userId
   * that was encrypted in the URL.
   */
  void setUserFromUserId(String userId, boolean isAdmin, boolean isReadOnly) {
<span class="nc" id="L217">    User user = storageIo.getUser(userId);</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">    if (!user.getIsAdmin() &amp;&amp; isAdmin) {</span>
<span class="nc" id="L219">      user.setIsAdmin(true);    // If session says they are an admin (which is the case</span>
                                // if they are a Google Account with Developer access
    }
<span class="nc" id="L222">    user.setReadOnly(isReadOnly);</span>
<span class="nc" id="L223">    localUser.set(user);</span>
<span class="nc" id="L224">  }</span>

  /*
   * Clears the user for the current thread.
   *
   * &lt;p&gt;This method is called from {@link #doMyFilter} above.
   *
   * &lt;p&gt;This method is called from {@link WebStartFileServlet}, a non-filtered
   * servlet.
   */
  @VisibleForTesting
  void removeUser() {
<span class="nc" id="L236">    localUser.set(null);</span>
<span class="nc" id="L237">  }</span>

  /* (non-Javadoc)
   * @see javax.servlet.Filter#destroy()
   */
  @Override
  public void destroy() {
<span class="nc" id="L244">  }</span>

  /* (non-Javadoc)
   * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
   */
  @Override
  public void init(FilterConfig arg0) throws ServletException {
<span class="nc" id="L251">  }</span>

  // --- Support Routines for encrypted cookies --- //

  public static class UserInfo implements Serializable {
<span class="nc" id="L256">    String userId = &quot;&quot;;</span>
<span class="nc" id="L257">    boolean isAdmin = false;</span>
<span class="nc" id="L258">    boolean isReadOnly = false;</span>
    long ts;

<span class="nc" id="L261">    transient boolean modified = false;</span>

<span class="nc" id="L263">    public UserInfo() {</span>
<span class="nc" id="L264">      this.ts = System.currentTimeMillis();</span>
<span class="nc" id="L265">    }</span>

    public boolean getReadOnly() {
<span class="nc" id="L268">      return this.isReadOnly;</span>
    }

<span class="nc" id="L271">    public UserInfo(String userId, boolean isAdmin) {</span>
<span class="nc" id="L272">      this.userId = userId;</span>
<span class="nc" id="L273">      this.isAdmin = isAdmin;</span>
<span class="nc" id="L274">      this.ts = System.currentTimeMillis();</span>
<span class="nc" id="L275">    }</span>

    public void setUserId(String userId) {
<span class="nc" id="L278">      this.userId = userId;</span>
<span class="nc" id="L279">      modified = true;</span>
<span class="nc" id="L280">    }</span>

    public void setReadOnly(boolean value) {
<span class="nc" id="L283">      this.isReadOnly = value;</span>
<span class="nc" id="L284">      modified = true;</span>
<span class="nc" id="L285">    }</span>

    public String getUserId() {
<span class="nc" id="L288">      return userId;</span>
    }

    public boolean getIsAdmin() {
<span class="nc" id="L292">      return isAdmin;</span>
    }

    public void setIsAdmin(boolean isAdmin) {
<span class="nc" id="L296">      this.isAdmin = isAdmin;</span>
<span class="nc" id="L297">      modified = true;</span>
<span class="nc" id="L298">    }</span>

    public String buildCookie(boolean ifNeeded) {
      try {
<span class="nc" id="L302">        long offset = System.currentTimeMillis() - this.ts;</span>
<span class="nc" id="L303">        offset /= 1000;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (offset &gt; (60*renewTime.get())) {    // Renew if it is time</span>
<span class="nc" id="L305">          modified = true;</span>
<span class="nc" id="L306">          ts = System.currentTimeMillis();</span>
        }
<span class="nc bnc" id="L308" title="All 4 branches missed.">        if (!ifNeeded || modified) {</span>
<span class="nc" id="L309">          Crypter crypter = getCrypter();</span>
<span class="nc" id="L310">          CookieAuth.cookie cookie = CookieAuth.cookie.newBuilder()</span>
<span class="nc" id="L311">            .setUuid(this.userId)</span>
<span class="nc" id="L312">            .setTs(this.ts)</span>
<span class="nc" id="L313">            .setIsAdmin(this.isAdmin)</span>
<span class="nc" id="L314">            .setIsReadOnly(this.isReadOnly).build();</span>
<span class="nc" id="L315">          return Base64Coder.encode(crypter.encrypt(cookie.toByteArray()));</span>
        } else {
<span class="nc" id="L317">          return null;</span>
        }
<span class="nc" id="L319">      } catch (Exception e) {</span>
<span class="nc" id="L320">        throw new RuntimeException(e);</span>
      }
    }

    // Verify the timestamp
    boolean isValid() {
<span class="nc" id="L326">      long offset = System.currentTimeMillis() - this.ts;</span>
<span class="nc" id="L327">      offset /= 1000;</span>

      // Reject if older then idleTimeout (minutes) or if greater then
      // 60 seconds in the future. We allow for 60 seconds in the
      // future to deal with potential clock skew between app inventor
      // servers

<span class="nc bnc" id="L334" title="All 4 branches missed.">      if (offset &lt; -60 || offset &gt; (60*idleTimeout.get())) {</span>
<span class="nc" id="L335">        return false;</span>
      } else {
<span class="nc" id="L337">        return true;</span>
      }
    }
  }

  public static UserInfo getUserInfo(HttpServletRequest request) {
    try {
<span class="nc" id="L344">      Cookie [] cookies = request.getCookies();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      if (cookies != null)</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">          if (&quot;AppInventor&quot;.equals(cookie.getName())) {</span>
<span class="nc" id="L348">            String rawData = cookie.getValue();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L350">              LOG.info(&quot;getUserInfo: rawCookie = &quot; + rawData);</span>
            }
<span class="nc" id="L352">            Crypter crypter = getCrypter();</span>
<span class="nc" id="L353">            CookieAuth.cookie cookieToken = CookieAuth.cookie.parseFrom(</span>
<span class="nc" id="L354">              crypter.decrypt(Base64Coder.decode(rawData)));</span>
<span class="nc" id="L355">            UserInfo uInfo = new UserInfo();</span>
<span class="nc" id="L356">            uInfo.userId = cookieToken.getUuid();</span>
<span class="nc" id="L357">            uInfo.ts = cookieToken.getTs();</span>
<span class="nc" id="L358">            uInfo.isAdmin = cookieToken.getIsAdmin();</span>
<span class="nc" id="L359">            uInfo.isReadOnly = cookieToken.getIsReadOnly();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (uInfo.isValid()) {</span>
<span class="nc" id="L361">              return uInfo;</span>
            } else {
<span class="nc" id="L363">              return null;</span>
            }
          }
        }
<span class="nc" id="L367">      return null;</span>
<span class="nc" id="L368">    } catch (KeyczarException e) {</span>
<span class="nc" id="L369">      LOG.log(Level.SEVERE, &quot;Error parsing provided cookie&quot;, e);</span>
<span class="nc" id="L370">      return null;</span>
<span class="nc" id="L371">    } catch (Exception e) {</span>
<span class="nc" id="L372">      throw new RuntimeException(e);</span>
    }
  }

  private static Crypter getCrypter() throws KeyczarException {
<span class="nc" id="L377">    synchronized(crypterSync) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">      if (crypter != null) {</span>
<span class="nc" id="L379">        return crypter;</span>
      } else {
<span class="nc" id="L381">        crypter = new Crypter(sessionKeyFile.get());</span>
<span class="nc" id="L382">        return crypter;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>