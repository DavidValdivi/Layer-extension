<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Security.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.server.project.utils</a> &gt; <span class="el_source">Security.java</span></div><h1>Security.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.server.project.utils;

import com.google.appinventor.server.encryption.EncryptionException;
import com.google.appinventor.server.encryption.EncryptionStrategy;
import com.google.appinventor.server.encryption.Encryptor;
import com.google.appinventor.server.storage.StorageIo;

import java.math.BigInteger;

/**
 * Security related helper functions.
 *
 * @author markf@google.com (Mark Friedman)
 */
public class Security {
  // Radix of the encrypted userID/projectID value
  private static final int ENCRYPTED_ID_RADIX = Character.MAX_RADIX;

  // Number of hex-digits for projectID (bits in a long divided by bits in a hex digit)
  private static final int ID_DIGITS = Long.SIZE / 4;

<span class="fc" id="L28">  private static final Encryptor encryptor = EncryptionStrategy.WRITE;</span>

  private Security() {  // COV_NF_LINE
  }  // COV_NF_LINE

  /**
   * Encrypts a user ID and a project ID so that it can be included in an URL
   * without leaking information. The encryption key is the same across all
   * servers so that any server can decrypt a request.
   *
   * @param userId  user ID
   * @param projectId  project ID
   * @return  an encrypted string safe to include in an URL
   */
  public static String encryptUserAndProjectId(String userId, long projectId)
      throws EncryptionException {
<span class="fc bfc" id="L44" title="All 4 branches covered.">    if ((userId == null) || (userId.isEmpty())) {</span>
<span class="fc" id="L45">      throw new EncryptionException(&quot;Trying to encrypt a null userId&quot;);</span>
    }
    // We encrypt the projectId as a fixed number of digits, followed by
    // the arbitrary length userId.
<span class="fc" id="L49">    String plain = String.format(&quot;%1$0&quot; + ID_DIGITS + &quot;x&quot;, projectId) + userId;</span>
<span class="fc" id="L50">    BigInteger bigint = new BigInteger(padBytes(encryptor.encrypt(plain.getBytes())));</span>
<span class="fc" id="L51">    return bigint.toString(ENCRYPTED_ID_RADIX);</span>
  }

  /**
   * Decrypt the user ID from an encrypted string generated by
   * {@link #encryptUserAndProjectId(String, long)}.
   *
   * @param idEnc  string generated by encryptUserAndProjectId
   * @return  the userId parameter that was originally passed to
   *          encryptUserAndProjectId or null
   *          if the encrypted string was invalid
   */
  public static String decryptUserId(String idEnc) throws EncryptionException {
    try {
      // Decrypt, skip the projectId (fixed length) and return the
      // rest of the decrypted string as the userId
<span class="fc" id="L67">      BigInteger bigint = new BigInteger(idEnc, ENCRYPTED_ID_RADIX);</span>
<span class="fc" id="L68">      String decryptedString = new String(encryptor.decrypt(unpadBytes(bigint.toByteArray())));</span>
<span class="fc" id="L69">      return decryptedString.substring(ID_DIGITS);</span>
<span class="fc" id="L70">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L71">      throw new EncryptionException(e);</span>
    }
  }

  /**
   * Decrypt the project ID from an encrypted string generated by
   * {@link #encryptUserAndProjectId(String, long)}.
   *
   * @param idEnc  string generated by encryptUserAndProjectId
   * @return  the projectId parameter that was originally passed to
   *          encryptUserAndProjectId or
   *          {@link StorageIo#INVALID_PROJECTID} if the encrypted string
   *          was invalid
   */
  public static long decryptProjectId(String idEnc) throws EncryptionException {
    try {
<span class="fc" id="L87">      BigInteger bigint = new BigInteger(idEnc, ENCRYPTED_ID_RADIX);</span>
<span class="fc" id="L88">      String decryptedString = new String(encryptor.decrypt(unpadBytes(bigint.toByteArray())));</span>
      // The projectId is the first ID_DIGITS characters of the decrypted string
<span class="fc" id="L90">      return new BigInteger(decryptedString.substring(0, ID_DIGITS), 16).longValue();</span>
<span class="fc" id="L91">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L92">      throw new EncryptionException(e);</span>
    }
  }

  /*
   * Prepend a non-zero byte to the beginning of the byte array and return the
   * new array.
   */
  private static byte[] padBytes(byte[] byteArray) {
<span class="fc" id="L101">    byte[] paddedBytes = new byte[byteArray.length + 1];</span>
<span class="fc" id="L102">    paddedBytes[0] = 0x1; // anything non-zero is good</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">    for (int i = 0; i &lt; byteArray.length; i++) {</span>
<span class="fc" id="L104">      paddedBytes[i+1] = byteArray[i];</span>
    }
<span class="fc" id="L106">    return paddedBytes;</span>
  }

  /*
   * Remove the first byte from the beginning of the byte array and return the
   * new array.
   */
  private static byte[] unpadBytes(byte[] paddedByteArray) {
<span class="fc" id="L114">    return java.util.Arrays.copyOfRange(paddedByteArray, 1, paddedByteArray.length);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>