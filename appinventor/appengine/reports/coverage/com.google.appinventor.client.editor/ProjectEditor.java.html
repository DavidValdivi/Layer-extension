<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProjectEditor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.editor</a> &gt; <span class="el_source">ProjectEditor.java</span></div><h1>ProjectEditor.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.editor;

import com.google.appinventor.client.Ode;
import com.google.appinventor.client.explorer.project.Project;
import com.google.appinventor.client.output.OdeLog;
import com.google.appinventor.client.settings.Settings;
import com.google.appinventor.shared.settings.SettingsConstants;
import com.google.appinventor.client.settings.project.ProjectSettings;
import com.google.appinventor.shared.rpc.project.ProjectRootNode;
import com.google.common.collect.Maps;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.DeckPanel;
import com.google.gwt.user.client.ui.VerticalPanel;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * Abstract superclass for all project editors.
 * Each ProjectEditor is associated with a single project and may have multiple
 * FileEditors open in a DeckPanel.
 * 
 * TODO(sharon): consider merging this into YaProjectEditor, since we now
 * only have one type of project editor. 
 *
 * @author lizlooney@google.com (Liz Looney)
 */
public abstract class ProjectEditor extends Composite {

  protected final ProjectRootNode projectRootNode;
  protected final long projectId;
  protected final Project project;

  // Invariants: openFileEditors, fileIds, and deckPanel contain corresponding
  // elements, i.e., if a FileEditor is in openFileEditors, its fileid should be
  // in fileIds and the FileEditor should be in deckPanel. If selectedFileEditor
  // is non-null, it is one of the file editors in openFileEditors and the 
  // one currently showing in deckPanel. 
  private final Map&lt;String, FileEditor&gt; openFileEditors;
  protected final List&lt;String&gt; fileIds; 
<span class="nc" id="L52">  private final HashMap&lt;String,String&gt; locationHashMap = new HashMap&lt;String,String&gt;();</span>
  private final DeckPanel deckPanel;
  private FileEditor selectedFileEditor;
<span class="nc" id="L55">  private final TreeMap&lt;String, Boolean&gt; screenHashMap = new TreeMap&lt;String, Boolean&gt;();</span>

  /**
   * Creates a {@code ProjectEditor} instance.
   *
   * @param projectRootNode  the project root node
   */
<span class="nc" id="L62">  public ProjectEditor(ProjectRootNode projectRootNode) {</span>
<span class="nc" id="L63">    this.projectRootNode = projectRootNode;</span>
<span class="nc" id="L64">    projectId = projectRootNode.getProjectId();</span>
<span class="nc" id="L65">    project = Ode.getInstance().getProjectManager().getProject(projectId);</span>

<span class="nc" id="L67">    openFileEditors = Maps.newHashMap();</span>
<span class="nc" id="L68">    fileIds = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L70">    deckPanel = new DeckPanel();</span>

<span class="nc" id="L72">    VerticalPanel panel = new VerticalPanel();</span>
<span class="nc" id="L73">    panel.add(deckPanel);</span>
<span class="nc" id="L74">    deckPanel.setSize(&quot;100%&quot;, &quot;100%&quot;);</span>
<span class="nc" id="L75">    panel.setSize(&quot;100%&quot;, &quot;100%&quot;);</span>
<span class="nc" id="L76">    initWidget(panel);</span>
    // Note: I'm not sure that the setSize call below does anything useful.
<span class="nc" id="L78">    setSize(&quot;100%&quot;, &quot;100%&quot;);</span>
<span class="nc" id="L79">  }</span>

  /**
   * Processes the project before loading into the project editor.
   * To do any any pre-processing of the Project
   * Calls the loadProject() after prepareProject() is fully executed.
   * Currently, prepareProject loads all external components associated with project.
   */
  public abstract void processProject();

  /**
   * Called when the ProjectEditor widget is loaded after having been hidden. 
   * Subclasses must implement this method, taking responsibility for causing 
   * the onShow method of the selected file editor to be called and for updating 
   * any other UI elements related to showing the project editor.
   */
  protected abstract void onShow();
  
  /**
   * Called when the ProjectEditor widget is about to be unloaded. Subclasses
   * must implement this method, taking responsibility for causing the onHide 
   * method of the selected file editor to be called and for updating any 
   * other UI elements related to hiding the project editor.
   */
  protected abstract void onHide();

  public final void setScreenCheckboxState(String screen, Boolean isChecked) {
<span class="nc" id="L106">    screenHashMap.put(screen, isChecked);</span>
<span class="nc" id="L107">  }</span>

  public final Boolean getScreenCheckboxState(String screen) {
<span class="nc" id="L110">    return screenHashMap.get(screen);</span>
  }

  public final String getScreenCheckboxMapString() {
<span class="nc" id="L114">    String screenCheckboxMap = &quot;&quot;;</span>
<span class="nc" id="L115">    int count = 0;</span>
<span class="nc" id="L116">    Set&lt;String&gt; screens = screenHashMap.keySet();</span>
<span class="nc" id="L117">    int size = screens.size();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    for (String screen : screens) {</span>
<span class="nc" id="L119">      Boolean isChecked = screenHashMap.get(screen);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      if (isChecked == null) {</span>
<span class="nc" id="L121">        continue;</span>
      }
<span class="nc bnc" id="L123" title="All 2 branches missed.">      String isCheckedString = (isChecked) ? &quot;True&quot; : &quot;False&quot;;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      String separator = (count == size) ? &quot;&quot; : &quot; &quot;;</span>
<span class="nc" id="L125">      screenCheckboxMap += screen + &quot;:&quot; + isCheckedString + separator;</span>
<span class="nc" id="L126">    }</span>
<span class="nc" id="L127">    return screenCheckboxMap;</span>
  }

  public final void buildScreenHashMap(String screenCheckboxMap) {
<span class="nc" id="L131">    String[] pairs = screenCheckboxMap.split(&quot; &quot;);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">    for (String pair : pairs) {</span>
<span class="nc" id="L133">      String[] mapping = pair.split(&quot;:&quot;);</span>
<span class="nc" id="L134">      String screen = mapping[0];</span>
<span class="nc" id="L135">      Boolean isChecked = Boolean.parseBoolean(mapping[1]);</span>
<span class="nc" id="L136">      screenHashMap.put(screen, isChecked);</span>
    }
<span class="nc" id="L138">  }</span>

  /**
   * Adds a file editor to this project editor.
   *
   * @param fileEditor  file editor to add
   */
  public final void addFileEditor(FileEditor fileEditor) {
<span class="nc" id="L146">    String fileId = fileEditor.getFileId();</span>
<span class="nc" id="L147">    openFileEditors.put(fileId, fileEditor);</span>
<span class="nc" id="L148">    fileIds.add(fileId);</span>
    
<span class="nc" id="L150">    deckPanel.add(fileEditor);</span>
<span class="nc" id="L151">  }</span>

  /**
   * Inserts a file editor in this editor at the specified index.
   *
   * @param fileEditor  file editor to insert
   * @param beforeIndex  the index before which fileEditor will be inserted
   */
  public final void insertFileEditor(FileEditor fileEditor, int beforeIndex) {
<span class="nc" id="L160">    String fileId = fileEditor.getFileId();</span>
<span class="nc" id="L161">    openFileEditors.put(fileId, fileEditor);</span>
<span class="nc" id="L162">    fileIds.add(beforeIndex, fileId);</span>
<span class="nc" id="L163">    deckPanel.insert(fileEditor, beforeIndex);</span>
<span class="nc" id="L164">    OdeLog.log(&quot;Inserted file editor for &quot; + fileEditor.getFileId() + &quot; at pos &quot; + beforeIndex);</span>

<span class="nc" id="L166">  }</span>

  /**
   * Selects the given file editor in the deck panel and calls its onShow()
   * method. Calls onHide() for a previously selected file editor if there was 
   * one (and it wasn't the same one).
   * 
   * Note: all actions that cause the selected file editor to change should
   * be going through DesignToolbar.SwitchScreenAction.execute(), which calls
   * this method. If you're thinking about calling this method directly from 
   * somewhere else, please reconsider!
   *
   * @param fileEditor  file editor to select
   */
  public final void selectFileEditor(FileEditor fileEditor) {
<span class="nc" id="L181">    int index = deckPanel.getWidgetIndex(fileEditor);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (index == -1) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (fileEditor != null) {</span>
<span class="nc" id="L184">        OdeLog.wlog(&quot;Can't find widget for fileEditor &quot; + fileEditor.getFileId());</span>
      } else {
<span class="nc" id="L186">        OdeLog.wlog(&quot;Not expecting selectFileEditor(null)&quot;);</span>
      }
    }
<span class="nc bnc" id="L189" title="All 2 branches missed.">    OdeLog.log(&quot;ProjectEditor: got selectFileEditor for &quot; </span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        + ((fileEditor == null) ? null : fileEditor.getFileId())</span>
        +  &quot; selectedFileEditor is &quot; 
<span class="nc" id="L192">        + ((selectedFileEditor == null) ? null : selectedFileEditor.getFileId()));</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">    if (selectedFileEditor != null &amp;&amp; selectedFileEditor != fileEditor) {</span>
<span class="nc" id="L194">      selectedFileEditor.onHide();</span>
    }
    // Note that we still want to do the following statements even if 
    // selectedFileEditor == fileEditor already. This handles the case of switching back
    // to a previously opened project from another project.
<span class="nc" id="L199">    selectedFileEditor = fileEditor;</span>
<span class="nc" id="L200">    deckPanel.showWidget(index);</span>
<span class="nc" id="L201">    selectedFileEditor.onShow();</span>
<span class="nc" id="L202">  }</span>

  /**
   * Returns the file editor for the given file ID.
   *
   * @param fileId  file ID of the file
   */
  public final FileEditor getFileEditor(String fileId) {
<span class="nc" id="L210">    return openFileEditors.get(fileId);</span>
  }
  
  /**
   * Returns the set of open file editors
   */
  public final Iterable&lt;FileEditor&gt; getOpenFileEditors() {
<span class="nc" id="L217">    return Collections.unmodifiableCollection(openFileEditors.values());</span>
  }
  
  /**
   * Returns the currently selected file editor
   */
  protected final FileEditor getSelectedFileEditor() {
<span class="nc" id="L224">    return selectedFileEditor;</span>
  }

  /**
   * Closes the file editors for the given file IDs, without saving.
   * This is used when the files are about to be deleted. If  
   * selectedFileEditor is closed, sets selectedFileEditor to null.
   *
   * @param closeFileIds  file IDs of the files to be closed
   */
  public final void closeFileEditors(String[] closeFileIds) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">    for (String fileId : closeFileIds) {</span>
<span class="nc" id="L236">      FileEditor fileEditor = openFileEditors.remove(fileId);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (fileEditor == null) {</span>
<span class="nc" id="L238">        OdeLog.elog(&quot;File editor is unexpectedly null for &quot; + fileId);</span>
<span class="nc" id="L239">        continue;</span>
      }
<span class="nc" id="L241">      int index = deckPanel.getWidgetIndex(fileEditor);</span>
<span class="nc" id="L242">      fileIds.remove(index);</span>
<span class="nc" id="L243">      deckPanel.remove(fileEditor);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      if (selectedFileEditor == fileEditor) {</span>
<span class="nc" id="L245">        selectedFileEditor.onHide();</span>
<span class="nc" id="L246">        selectedFileEditor = null;</span>
      }
<span class="nc" id="L248">      fileEditor.onClose();</span>
    }
<span class="nc" id="L250">  }</span>
  
  /**
   * Returns the value of a project settings property.
   *
   * @param category  property category
   * @param name  property name
   * @return the property value
   */
  public final String getProjectSettingsProperty(String category, String name) {
<span class="nc" id="L260">    ProjectSettings projectSettings = project.getSettings();</span>
<span class="nc" id="L261">    Settings settings = projectSettings.getSettings(category);</span>
<span class="nc" id="L262">    return settings.getPropertyValue(name);</span>
  }

  /**
   * Changes the value of a project settings property.
   *
   * @param category  property category
   * @param name  property name
   * @param newValue  new property value
   */
  public final void changeProjectSettingsProperty(String category, String name, String newValue) {
<span class="nc" id="L273">    ProjectSettings projectSettings = project.getSettings();</span>
<span class="nc" id="L274">    Settings settings = projectSettings.getSettings(category);</span>
<span class="nc" id="L275">    String currentValue = settings.getPropertyValue(name);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (!newValue.equals(currentValue)) {</span>
<span class="nc" id="L277">      OdeLog.log(&quot;ProjectEditor: changeProjectSettingsProperty: &quot; + name + &quot; &quot; + currentValue +</span>
                 &quot; =&gt; &quot; + newValue);
<span class="nc" id="L279">      settings.changePropertyValue(name, newValue);</span>
      // Deal with the Tutorial Panel
<span class="nc" id="L281">      Ode ode = Ode.getInstance();</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (name.equals(&quot;TutorialURL&quot;)) {</span>
<span class="nc" id="L283">        ode.setTutorialURL(newValue);</span>
      }
<span class="nc" id="L285">      ode.getEditorManager().scheduleAutoSave(projectSettings);</span>
    }
<span class="nc" id="L287">  }</span>

  /**
   * Keep track of components that require the
   * &quot;android.permission.ACCESS_FINE_LOCATION&quot; (and related
   * permissions). This code is in particular for use of the WebViewer
   * component. The WebViewer exports the Javascript location
   * API. However it cannot be used by an app with location
   * permissions. Each WebViewer has a &quot;UsesLocation&quot; property which
   * is only available from the designer. Each WebViewer then
   * registers its value here. Each time this hashtable is updated we
   * recompute whether or not location permission is needed based on a
   * logical OR of all of the WebViewer components registered. Note:
   * Even if no WebViewer component requires location permission, other
   * components, such as the LocationSensor may require it. That is
   * handled via the @UsesPermissions mechanism and is independent of
   * this code.
   *
   * @param componentName The name of the component registering location permission
   * @param newValue either &quot;True&quot; or &quot;False&quot; indicating whether permission is need.
   */

  public final void recordLocationSetting(String componentName, String newValue) {
<span class="nc" id="L310">    OdeLog.log(&quot;ProjectEditor: recordLocationSetting(&quot; + componentName + &quot;,&quot; + newValue + &quot;)&quot;);</span>
<span class="nc" id="L311">    locationHashMap.put(componentName, newValue);</span>
<span class="nc" id="L312">    recomputeLocationPermission();</span>
<span class="nc" id="L313">  }</span>

  private final void recomputeLocationPermission() {
<span class="nc" id="L316">    String usesLocation = &quot;False&quot;;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    for (String c : locationHashMap.values()) {</span>
<span class="nc" id="L318">      OdeLog.log(&quot;ProjectEditor:recomputeLocationPermission: &quot; + c);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (c.equals(&quot;True&quot;)) {</span>
<span class="nc" id="L320">        usesLocation = &quot;True&quot;;</span>
<span class="nc" id="L321">        break;</span>
      }
<span class="nc" id="L323">    }</span>
<span class="nc" id="L324">    changeProjectSettingsProperty(SettingsConstants.PROJECT_YOUNG_ANDROID_SETTINGS, SettingsConstants.YOUNG_ANDROID_SETTINGS_USES_LOCATION,</span>
      usesLocation);
<span class="nc" id="L326">  }</span>

  public void clearLocation(String componentName) {
<span class="nc" id="L329">    OdeLog.log(&quot;ProjectEditor:clearLocation: clearing &quot; + componentName);</span>
<span class="nc" id="L330">    locationHashMap.remove(componentName);</span>
<span class="nc" id="L331">    recomputeLocationPermission();</span>
<span class="nc" id="L332">  }</span>

  /**
   * Notification that the file with the given file ID has been saved.
   *
   * @param fileId  file ID of the file that was saved
   */
  public final void onSave(String fileId) {
<span class="nc" id="L340">    FileEditor fileEditor = openFileEditors.get(fileId);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">    if (fileEditor != null) {</span>
<span class="nc" id="L342">      fileEditor.onSave();</span>
    }
<span class="nc" id="L344">  }</span>

  // GWT Widget methods

  @Override
  protected void onLoad() {
    // onLoad is called immediately after a widget becomes attached to the browser's document.
    // onLoad will be called both when a project is opened the first time and when an
    // already-opened project is re-opened.
    // This is different from the ProjectEditor method loadProject, which is called to load the
    // project just after the editor is created.
<span class="nc" id="L355">    OdeLog.log(&quot;ProjectEditor: got onLoad for project &quot; + projectId);</span>
<span class="nc" id="L356">    super.onLoad();</span>
<span class="nc" id="L357">    String tutorialURL = getProjectSettingsProperty(SettingsConstants.PROJECT_YOUNG_ANDROID_SETTINGS,</span>
                                                    SettingsConstants.YOUNG_ANDROID_SETTINGS_TUTORIAL_URL);
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (!tutorialURL.isEmpty()) {</span>
<span class="nc" id="L360">      Ode ode = Ode.getInstance();</span>
<span class="nc" id="L361">      ode.setTutorialURL(tutorialURL);</span>
    }

<span class="nc" id="L364">    onShow();</span>
<span class="nc" id="L365">  }</span>

  @Override
  protected void onUnload() {
    // onUnload is called immediately before a widget becomes detached from the browser's document.
<span class="nc" id="L370">    Ode ode = Ode.getInstance();</span>
<span class="nc" id="L371">    ode.setTutorialVisible(false);</span>
<span class="nc" id="L372">    ode.getDesignToolbar().setTutorialToggleVisible(false);</span>
<span class="nc" id="L373">    OdeLog.log(&quot;ProjectEditor: got onUnload for project &quot; + projectId);</span>
<span class="nc" id="L374">    super.onUnload();</span>
<span class="nc" id="L375">    onHide();</span>
<span class="nc" id="L376">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>