<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EditorManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.editor</a> &gt; <span class="el_source">EditorManager.java</span></div><h1>EditorManager.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.editor;

import static com.google.appinventor.client.Ode.MESSAGES;

import com.google.appinventor.client.ErrorReporter;
import com.google.appinventor.client.Ode;
import com.google.appinventor.client.OdeAsyncCallback;
import com.google.appinventor.client.editor.youngandroid.YaBlocksEditor;
import com.google.appinventor.client.editor.youngandroid.YailGenerationException;
import com.google.appinventor.client.explorer.project.Project;
import com.google.appinventor.client.settings.project.ProjectSettings;
import com.google.appinventor.shared.rpc.BlocksTruncatedException;
import com.google.appinventor.shared.rpc.project.FileDescriptorWithContent;
import com.google.appinventor.shared.rpc.project.ProjectRootNode;
import com.google.common.collect.Maps;
import com.google.gwt.user.client.Command;
import com.google.gwt.user.client.Timer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Manager class for opened project editors.
 *
 * @author lizlooney@google.com (Liz Looney)
 */
public final class EditorManager {
  // Map of project IDs to open project editors
  private final Map&lt;Long, ProjectEditor&gt; openProjectEditors;

  // Timeout (in ms) after which changed content is auto-saved if the user did
  // not continue typing.
  // TODO(user): Make this configurable.
  private static final int AUTO_SAVE_IDLE_TIMEOUT = 5000;
  // Currently set to 5 seconds. Note: the GWT code as a ClosingHandler
  // that will perform a save when the user closes the window.

  // Timeout (in ms) after which changed content is auto-saved even if the user
  // continued typing.
  // TODO(user): Make this configurable.
  private static final int AUTO_SAVE_FORCED_TIMEOUT = 30000;

  // Fields used for saving and auto-saving.
  private final Set&lt;ProjectSettings&gt; dirtyProjectSettings;
  private final Set&lt;FileEditor&gt; dirtyFileEditors;
  private final HashMap&lt;String,FileEditor&gt; pendingFileEditors;
  private final Timer autoSaveTimer;
  private boolean autoSaveIsScheduled;
  private long autoSaveRequestTime;

<span class="nc" id="L62">  private class DateHolder {</span>
    long date;
    long projectId;
  }

  /**
   * Creates the editor manager.
   */
<span class="nc" id="L70">  public EditorManager() {</span>
<span class="nc" id="L71">    openProjectEditors = Maps.newHashMap();</span>

<span class="nc" id="L73">    dirtyProjectSettings = new HashSet&lt;ProjectSettings&gt;();</span>
<span class="nc" id="L74">    dirtyFileEditors = new HashSet&lt;FileEditor&gt;();</span>
<span class="nc" id="L75">    pendingFileEditors = new HashMap&lt;String,FileEditor&gt;();</span>

<span class="nc" id="L77">    autoSaveTimer = new Timer() {</span>
      @Override
      public void run() {
        // When the timer goes off, save all dirtyProjectSettings and
        // dirtyFileEditors.
<span class="nc" id="L82">        Ode.getInstance().lockScreens(true); // Lock out changes</span>
<span class="nc" id="L83">        saveDirtyEditors(new Command() {</span>
            @Override
            public void execute() {
<span class="nc" id="L86">              Ode.getInstance().lockScreens(false); // I/O finished, unlock</span>
<span class="nc" id="L87">            }</span>
          });
<span class="nc" id="L89">      }</span>
    };
<span class="nc" id="L91">  }</span>

  /**
   * Opens the project editor for the given project.
   * If there is an editor already open for the project, it will be returned.
   * Otherwise, it will create an appropriate editor for the project.
   *
   * @param projectRootNode  the root node of the project to open
   * @return  project editor for the given project
   */
  public ProjectEditor openProject(ProjectRootNode projectRootNode) {
<span class="nc" id="L102">    long projectId = projectRootNode.getProjectId();</span>
<span class="nc" id="L103">    ProjectEditor projectEditor = openProjectEditors.get(projectId);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (projectEditor == null) {</span>
      // No open editor for this project yet.
      // Use the ProjectEditorRegistry to get the factory and create the project editor.
<span class="nc" id="L107">      ProjectEditorFactory factory = Ode.getProjectEditorRegistry().get(projectRootNode);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">      if (factory != null) {</span>
<span class="nc" id="L109">        projectEditor = factory.createProjectEditor(projectRootNode);</span>

        // Add the editor to the openProjectEditors map.
<span class="nc" id="L112">        openProjectEditors.put(projectId, projectEditor);</span>
        
        // Tell the DesignToolbar about this project
<span class="nc" id="L115">        Ode.getInstance().getDesignToolbar().addProject(projectId, projectRootNode.getName());</span>

        // Prepare the project before Loading into the editor.
        // Components are prepared before the project is actually loaded.
        // Load the project into the editor. The actual loading is asynchronous.
<span class="nc" id="L120">        projectEditor.processProject();</span>
      }
    }
<span class="nc" id="L123">    return projectEditor;</span>
  }

  /**
   * Gets the open project editor of the given project ID.
   *
   * @param projectId the project ID
   * @return the ProjectEditor of the specified project, or null
   */
  public ProjectEditor getOpenProjectEditor(long projectId) {
<span class="nc" id="L133">    return openProjectEditors.get(projectId);</span>
  }

  /**
   * Closes the file editors for the specified files, without saving.
   * This is used when the files are about to be deleted.
   *
   * @param projectId  project ID
   * @param fileIds  file IDs of the file editors to be closed
   */
  public void closeFileEditors(long projectId, String[] fileIds) {
<span class="nc" id="L144">    ProjectEditor projectEditor = openProjectEditors.get(projectId);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">    if (projectEditor != null) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      for (String fileId : fileIds) {</span>
<span class="nc" id="L147">        FileEditor fileEditor = projectEditor.getFileEditor(fileId);</span>
        // in case the file is not open in an editor (possible?) check 
        // the FileEditors for null. 
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (fileEditor != null) {</span>
<span class="nc" id="L151">          dirtyFileEditors.remove(fileEditor);</span>
        }
      }
<span class="nc" id="L154">      projectEditor.closeFileEditors(fileIds);</span>
    }
<span class="nc" id="L156">  }</span>

  /**
   * Closes the project editor for a particular project, without saving.
   * Does not actually remove the editor from the ViewerBox.
   * This is used when the project is about to be deleted.
   *
   * @param projectId  ID of project whose editor is to be closed
   */
  public void closeProjectEditor(long projectId) {
    // TODO(lizlooney) - investigate whether the ProjectEditor and all its FileEditors stay in
    // memory even after we've removed them.
<span class="nc" id="L168">    Project project = Ode.getInstance().getProjectManager().getProject(projectId);</span>
<span class="nc" id="L169">    ProjectSettings projectSettings = project.getSettings();</span>
<span class="nc" id="L170">    dirtyProjectSettings.remove(projectSettings);</span>
<span class="nc" id="L171">    openProjectEditors.remove(projectId);</span>
<span class="nc" id="L172">  }</span>

  /**
   * Schedules auto-save of the given project settings.
   * This method can be called often, as the user is modifying project settings.
   *
   * @param projectSettings the project settings for which to schedule auto-save
   */
  public void scheduleAutoSave(ProjectSettings projectSettings) {
    // Add the project settings to the dirtyProjectSettings list.
<span class="nc" id="L182">    dirtyProjectSettings.add(projectSettings);</span>
<span class="nc" id="L183">    scheduleAutoSaveTimer();</span>
<span class="nc" id="L184">  }</span>

  /**
   * Schedules auto-save of the given file editor.
   * This method can be called often, as the user is modifying a file.
   *
   * @param fileEditor the file editor for which to schedule auto-save
   */
  public void scheduleAutoSave(FileEditor fileEditor) {
    // Add the file editor to the dirtyFileEditors list.
<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (!fileEditor.isDamaged()) { // Don't save damaged files</span>
<span class="nc" id="L195">      dirtyFileEditors.add(fileEditor);</span>
    } else {
<span class="nc" id="L197">      Ode.CLog(&quot;Not saving blocks for &quot; + fileEditor.getFileId() + &quot; because it is damaged.&quot;);</span>
    }
<span class="nc" id="L199">    scheduleAutoSaveTimer();</span>
<span class="nc" id="L200">  }</span>

  /**
   * Check whether there is an open project editor.
   *
   * @return true if at least one project is open (or in the process of opening), otherwise false
   */
  public boolean hasOpenEditor() {
<span class="nc bnc" id="L208" title="All 2 branches missed.">    return openProjectEditors.size() &gt; 0;</span>
  }

  /**
   * Schedules the auto-save timer.
   */
  private void scheduleAutoSaveTimer() {
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (autoSaveIsScheduled) {</span>
      // The auto-save timer is already scheduled.
      // The user is making multiple changes and, in general, we want to wait until they are idle
      // before saving. However, we don't want to delay the auto-save forever.
      // If the time that the auto-save was first requested wasn't too long ago, cancel and
      // reschedule the timer. Otherwise, leave the scheduled timer alone.
<span class="nc bnc" id="L221" title="All 2 branches missed.">      if (System.currentTimeMillis() - autoSaveRequestTime &lt; AUTO_SAVE_FORCED_TIMEOUT) {</span>
<span class="nc" id="L222">        autoSaveTimer.cancel();</span>
<span class="nc" id="L223">        autoSaveTimer.schedule(AUTO_SAVE_IDLE_TIMEOUT);</span>
      }
    } else {
      // The auto-save timer is not already scheduled.
      // Schedule it now and set autoSaveRequestTime.
<span class="nc" id="L228">      autoSaveTimer.schedule(AUTO_SAVE_IDLE_TIMEOUT);</span>
<span class="nc" id="L229">      autoSaveRequestTime = System.currentTimeMillis();</span>
<span class="nc" id="L230">      autoSaveIsScheduled = true;</span>
    }
<span class="nc" id="L232">  }</span>

  /**
   * Saves all modified files and project settings and calls the afterSaving
   * command after they have all been saved successfully.
   *
   * If any errors occur while saving, the afterSaving command will not be
   * executed.
   * If nothing needs to be saved, the afterSavingFiles command is called
   * immediately, not asynchronously.
   *
   * @param afterSaving  optional command to be executed after project
   *                     settings and file editors are saved successfully
   */
  public void saveDirtyEditors(final Command afterSaving) {
    // Note, We don't do any saving if we are in read only mode
<span class="nc bnc" id="L248" title="All 2 branches missed.">    if (Ode.getInstance().isReadOnly()) {</span>
<span class="nc" id="L249">      afterSaving.execute();</span>
<span class="nc" id="L250">      return;</span>
    }

    // Collect the files that need to be saved.
<span class="nc" id="L254">    List&lt;FileDescriptorWithContent&gt; filesToSave = new ArrayList&lt;FileDescriptorWithContent&gt;();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">    for (FileEditor fileEditor : dirtyFileEditors) {</span>
<span class="nc" id="L256">      FileDescriptorWithContent fileContent = new FileDescriptorWithContent(</span>
<span class="nc" id="L257">          fileEditor.getProjectId(), fileEditor.getFileId(), fileEditor.getRawFileContent());</span>
<span class="nc" id="L258">      filesToSave.add(fileContent);</span>
<span class="nc" id="L259">      pendingFileEditors.put(fileEditor.getFileId(), fileEditor); // pending save</span>
<span class="nc" id="L260">    }</span>
<span class="nc" id="L261">    dirtyFileEditors.clear();</span>

    // Collect the project settings that need to be saved.
<span class="nc" id="L264">    List&lt;ProjectSettings&gt; projectSettingsToSave = new ArrayList&lt;ProjectSettings&gt;();</span>
<span class="nc" id="L265">    projectSettingsToSave.addAll(dirtyProjectSettings);</span>
<span class="nc" id="L266">    dirtyProjectSettings.clear();</span>

<span class="nc" id="L268">    autoSaveTimer.cancel();</span>
<span class="nc" id="L269">    autoSaveIsScheduled = false;</span>

    // Keep count as each save operation finishes so we can set the projects' modified date and
    // call the afterSaving command after everything has been saved.
    // Each project settings is saved as a separate operation, but all files are saved as a single
    // save operation. So the initial value of pendingSaveOperations is the size of
    // projectSettingsToSave plus 1.
<span class="nc" id="L276">    final AtomicInteger pendingSaveOperations = new AtomicInteger(projectSettingsToSave.size() + 1);</span>
<span class="nc" id="L277">    final DateHolder dateHolder = new DateHolder();</span>
<span class="nc" id="L278">    Command callAfterSavingCommand = new Command() {</span>
      @Override
      public void execute() {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (pendingSaveOperations.decrementAndGet() == 0) {</span>
          // We get here when all save operations have completed, either
          // with success or not.
<span class="nc" id="L284">          pendingFileEditors.clear(); // Failed I/O will be back in dirtyFileEditors</span>
          // Execute the afterSaving command if one was given.
<span class="nc bnc" id="L286" title="All 2 branches missed.">          if (afterSaving != null) {</span>
<span class="nc" id="L287">            afterSaving.execute();</span>
          }
          // Set the project modification date to the returned date
          // for one of the saved files (it doesn't really matter which one).
<span class="nc bnc" id="L291" title="All 4 branches missed.">          if ((dateHolder.date != 0) &amp;&amp; (dateHolder.projectId != 0)) { // We have a date back from the server</span>
<span class="nc" id="L292">            Ode.getInstance().updateModificationDate(dateHolder.projectId, dateHolder.date);</span>
          }
        }
<span class="nc" id="L295">      }</span>
    };

    // Save all files at once (asynchronously).
<span class="nc" id="L299">    saveMultipleFilesAtOnce(filesToSave, callAfterSavingCommand, dateHolder);</span>

    // Save project settings one at a time (asynchronously).
<span class="nc bnc" id="L302" title="All 2 branches missed.">    for (ProjectSettings projectSettings : projectSettingsToSave) {</span>
<span class="nc" id="L303">      projectSettings.saveSettings(callAfterSavingCommand);</span>
<span class="nc" id="L304">    }</span>
<span class="nc" id="L305">  }</span>
  
  /**
   * For each block editor (screen) in the current project, generate and save yail code for the 
   * blocks.
   *
   * @param successCommand  optional command to be executed if yail generation and saving succeeds.
   * @param failureCommand  optional command to be executed if yail generation and saving fails.
   */
  public void generateYailForBlocksEditors(final Command successCommand, 
      final Command failureCommand) {
<span class="nc" id="L316">    List&lt;FileDescriptorWithContent&gt; yailFiles =  new ArrayList&lt;FileDescriptorWithContent&gt;();</span>
<span class="nc" id="L317">    long currentProjectId = Ode.getInstance().getCurrentYoungAndroidProjectId();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">    for (long projectId : openProjectEditors.keySet()) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (projectId == currentProjectId) {</span>
        // Generate yail for each blocks editor in this project and add it to the list of 
        // yail files. If an error occurs we stop the generation process, report the error, 
        // and return without executing nextCommand.
<span class="nc" id="L323">        ProjectEditor projectEditor = openProjectEditors.get(projectId);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (FileEditor fileEditor : projectEditor.getOpenFileEditors()) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">          if (fileEditor instanceof YaBlocksEditor) {</span>
<span class="nc" id="L326">            YaBlocksEditor yaBlocksEditor = (YaBlocksEditor) fileEditor;</span>
            try {
<span class="nc" id="L328">              yailFiles.add(yaBlocksEditor.getYail());</span>
<span class="nc" id="L329">            } catch (YailGenerationException e) {</span>
<span class="nc" id="L330">              ErrorReporter.reportInfo(MESSAGES.yailGenerationError(e.getFormName(), </span>
<span class="nc" id="L331">                  e.getMessage()));</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">              if (failureCommand != null) {</span>
<span class="nc" id="L333">                failureCommand.execute();</span>
              }
<span class="nc" id="L335">              return;</span>
<span class="nc" id="L336">            }</span>
          }
<span class="nc" id="L338">        }</span>
<span class="nc" id="L339">        break;</span>
      }
<span class="nc" id="L341">    }</span>
   
<span class="nc" id="L343">    Ode.getInstance().getProjectService().save(Ode.getInstance().getSessionId(),</span>
        yailFiles,
<span class="nc" id="L345">        new OdeAsyncCallback&lt;Long&gt;(MESSAGES.saveErrorMultipleFiles()) {</span>
      @Override
      public void onSuccess(Long date) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (successCommand != null) {</span>
<span class="nc" id="L349">          successCommand.execute();</span>
        }
<span class="nc" id="L351">      }</span>
      
      @Override
      public void onFailure(Throwable caught) {
<span class="nc" id="L355">        super.onFailure(caught);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (failureCommand != null) {</span>
<span class="nc" id="L357">          failureCommand.execute();</span>
        }
<span class="nc" id="L359">      }</span>
    });
<span class="nc" id="L361">  }</span>


  /**
   * This code used to send the contents of all changed files to the server
   * in the same RPC transaction. However we are now sending them separately
   * so that we can have more fine grained control over handling errors that
   * happen only on one file. In particular, we need to handle the case where
   * a trivial blocks workspace is attempting to be written over a non-trivial
   * file.
   *
   * If any unhandled errors occur while saving, the afterSavingFiles
   * command will not be executed.  If filesWithContent is empty, the
   * afterSavingFiles command is called immediately, not
   * asynchronously.
   *
   * @param filesWithContent  the files that need to be saved
   * @param afterSavingFiles  optional command to be executed after file
   *                          editors are saved.
   */
  private void saveMultipleFilesAtOnce(
      final List&lt;FileDescriptorWithContent&gt; filesWithContent, final Command afterSavingFiles, final DateHolder dateHolder) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (filesWithContent.isEmpty()) {</span>
      // No files needed saving.
      // Execute the afterSavingFiles command if one was given.
<span class="nc bnc" id="L386" title="All 2 branches missed.">      if (afterSavingFiles != null) {</span>
<span class="nc" id="L387">        afterSavingFiles.execute();</span>
      }

    } else {
<span class="nc bnc" id="L391" title="All 2 branches missed.">      for (FileDescriptorWithContent fileDescriptor : filesWithContent ) {</span>
<span class="nc" id="L392">        final long projectId = fileDescriptor.getProjectId();</span>
<span class="nc" id="L393">        final String fileId = fileDescriptor.getFileId();</span>
<span class="nc" id="L394">        final String content = fileDescriptor.getContent();</span>
<span class="nc" id="L395">        Ode.CLog(&quot;Saving fileId &quot; + fileId + &quot; for projectId &quot; + projectId);</span>
<span class="nc" id="L396">        Ode.getInstance().getProjectService().save2(Ode.getInstance().getSessionId(),</span>
<span class="nc" id="L397">          projectId, fileId, false, content, new OdeAsyncCallback&lt;Long&gt;(MESSAGES.saveErrorMultipleFiles()) {</span>
            @Override
            public void onSuccess(Long date) {
<span class="nc bnc" id="L400" title="All 2 branches missed.">              if (dateHolder.date != 0) {</span>
                // This sets the project modification time to that of one of
                // the successful file saves. It doesn't really matter which
                // file date we use, they will all be close. However it is important
                // to use some files date because that will be based on the server's
                // time. If we used the local clients time, then we may be off if the
                // client's computer's time isn't set correctly.
<span class="nc" id="L407">                dateHolder.date = date;</span>
<span class="nc" id="L408">                dateHolder.projectId = projectId;</span>
              }
<span class="nc bnc" id="L410" title="All 2 branches missed.">              if (afterSavingFiles != null) {</span>
<span class="nc" id="L411">                afterSavingFiles.execute();</span>
              }
<span class="nc" id="L413">            }</span>
            @Override
            public void onFailure(Throwable caught) {
              // Here is where we handle BlocksTruncatedException
<span class="nc bnc" id="L417" title="All 2 branches missed.">              if (caught instanceof BlocksTruncatedException) {</span>
<span class="nc" id="L418">                Ode.getInstance().blocksTruncatedDialog(projectId, fileId, content, this);</span>
              } else {
                // We mark the file editor as dirty again because the save failed.
                //
                // Note: I considered re-scheduling the auto-save and decided against
                // it. One reason we might be getting errors is due to a problem with
                // the server. If a lot of clients start re-scheduling saves, this might
                // make the situation worse due to the &quot;thundering Herd!&quot; So we compromise
                // we mark the editors as dirty, so the next update by the user to any
                // file will retry all of the non-saved files. The &quot;Save Project&quot; menu
                // item will also re-attempt the failed I/O
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (pendingFileEditors.containsKey(fileId)) {</span>
<span class="nc" id="L430">                  dirtyFileEditors.add(pendingFileEditors.get(fileId));</span>
                }
<span class="nc" id="L432">                super.onFailure(caught);</span>
              }
<span class="nc bnc" id="L434" title="All 2 branches missed.">              if (afterSavingFiles != null) { // Need to call this to decrement the count</span>
<span class="nc" id="L435">                afterSavingFiles.execute();   // of files saved (or not in this case)</span>
              }
<span class="nc" id="L437">            }</span>
          });
<span class="nc" id="L439">      }</span>
    }
<span class="nc" id="L441">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>