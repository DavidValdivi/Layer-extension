<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProjectNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.shared.rpc.project</a> &gt; <span class="el_source">ProjectNode.java</span></div><h1>ProjectNode.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.shared.rpc.project;

import com.google.gwt.user.client.rpc.IsSerializable;

import com.google.common.base.Preconditions;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Project nodes are used for the structural representation of a project. This
 * is the superclass for all project nodes.
 *
 * &lt;p&gt;The node can directly represent files or folders in the filesystem on
 * the backend, as well as 'virtual' files or folders. An example for a
 * virtual folder is a package node which maps to a series of nested folders.
 *
 * &lt;p&gt;Project nodes will be returned by the backend via RPC to the client
 * in the browser. Therefore they must be serializable. If there are any fields
 * that cannot be serialized, they must be marked as transient.
 *
 */
public abstract class ProjectNode implements Serializable, IsSerializable {

  // For serialization
  private static final long serialVersionUID = -6903337206811923033L;

  // Name of project node (does not need to match the name of the file/folder it represents)
  private String name;

  // ID to identify the file/folder represented by the project node on the backend
  private String fileId;

  // Parent node of this node, {@code null} for the root project node
  private ProjectNode parent;

  // Children of this node (corresponds to files in folder on backend)
  private List&lt;ProjectNode&gt; children;

  /**
   * Default constructor (for serialization only).
   * Unfortunately this will prevent any fields from being marked as final!
   */
<span class="nc" id="L52">  public ProjectNode() {</span>
<span class="nc" id="L53">  }</span>

  /**
   * Creates a new project node.
   *
   * @param name  project node name (can be different from file or folder
   *              represented by this node)
   * @param fileId  ID to identify the file/folder represented by the project
   *                node on the backend (can be {@code null} for 'virtual'
   *                folders)
   */
<span class="fc" id="L64">  public ProjectNode(String name, String fileId) {</span>
<span class="fc" id="L65">    this.name = name;</span>
<span class="fc" id="L66">    this.fileId = fileId;</span>
<span class="fc" id="L67">  }</span>

  /**
   * Adds another project node as a child to this project node.
   *
   * @param child  new child to be added to this node
   */
  public void addChild(ProjectNode child) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (children == null) {</span>
<span class="fc" id="L76">      children = new ArrayList&lt;ProjectNode&gt;();</span>
    }
<span class="fc" id="L78">    children.add(child);</span>
<span class="fc" id="L79">    child.setParent(this);</span>
<span class="fc" id="L80">  }</span>

  /**
   * Removes an existing child node from this project node.
   *
   * @param child  child to be removed from this node
   */
  public void removeChild(ProjectNode child) {
<span class="nc" id="L88">    Preconditions.checkNotNull(children);</span>
<span class="nc" id="L89">    children.remove(child);</span>
<span class="nc" id="L90">  }</span>

  /**
   * Sets a project node to be the parent of this project node.
   *
   * @param node  parent node for this node
   */
  protected void setParent(ProjectNode node) {
<span class="fc" id="L98">    parent = node;</span>
<span class="fc" id="L99">  }</span>

  /**
   * Returns the project node's parent.
   *
   * @return  parent project node ({@code null} for root node)
   */
  public ProjectNode getParent() {
<span class="nc" id="L107">    return parent;</span>
  }

  /**
   * Returns the root project node for this project node. This method can be
   * called on any project node within the project hierarchy.
   *
   * @return  root node of the associated project
   */
  public ProjectRootNode getProjectRoot() {
<span class="nc" id="L117">    return parent.getProjectRoot();</span>
  }

  /**
   * Returns the ID of the project associated with this node. This method can be
   * called on any project node within the project hierarchy.
   *
   * @return  ID of the associated project
   */
  public long getProjectId() {
<span class="nc" id="L127">    return getProjectRoot().getProjectId();</span>
  }

  /**
   * Returns the project type of the nodes in this project (all nodes within
   * a project share the same project type).
   *
   * &lt;p&gt;Note that {@link ProjectRootNode} subclasses need to override this
   * method!
   *
   * @return  type of the associated project
   */
  public String getProjectType() {
<span class="nc" id="L140">    return getProjectRoot().getProjectType();</span>
  }

  /**
   * Returns the name of this project node.
   *
   * @return  name of this node (doesn't have to be the same as the name of
   *          the file/folder represented by this node)
   */
  public String getName() {
<span class="fc" id="L150">    return name;</span>
  }

  /**
   * Returns the full name of this project node.
   *
   * @return  full name of this node
   */
  public String getFullName() {
    // The fileId is the full name of the node.
<span class="fc" id="L160">    return fileId;</span>
  }

  /**
   * Returns the ID for this project node.
   *
   * @return  ID to identify the file/folder represented by the project node
   *          on the backend (can be {@code null} for 'virtual' folders)
   */
  public String getFileId() {
<span class="fc" id="L170">    return fileId;</span>
  }

  /**
   * Returns an iterable for the children of this node.
   *
   * @return iterable
   */
  public Iterable&lt;ProjectNode&gt; getChildren() {
<span class="fc" id="L179">    List&lt;ProjectNode&gt; result = children;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    if (result == null) {</span>
<span class="fc" id="L181">      result = Collections.emptyList();</span>
    }
<span class="fc" id="L183">    return result;</span>
  }

  /**
   * Indicates whether a node is a source node.
   *
   * @return  {@code true} for source nodes, {@code false} otherwise
   */
  protected boolean isSourceNode() {
<span class="nc" id="L192">    return false;</span>
  }

  /**
   * Recursively looks for a project node with the given file ID.
   *
   * @param fileId  file ID to look for
   * @return  found project node or {@code null}
   */
   public ProjectNode findNode(String fileId) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (fileId.equals(getFileId())) {</span>
<span class="nc" id="L203">      return this;</span>
    }

<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (children != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      for (ProjectNode child : children) {</span>
<span class="nc" id="L208">        ProjectNode found = child.findNode(fileId);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (found != null) {</span>
<span class="nc" id="L210">          return found;</span>
        }
<span class="nc" id="L212">      }</span>
    }

<span class="nc" id="L215">    return null;</span>
  }

  /**
   * Recursively looks for a project node with the given type.
   *
   * @param type  class of node to look for
   * @return  found project node or {@code null}
   */
   public ProjectNode findNode(Class&lt;?&gt; type) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">     if (getClass().equals(type)) {</span>
<span class="nc" id="L226">       return this;</span>
     }

<span class="nc bnc" id="L229" title="All 2 branches missed.">     if (children != null) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">       for (ProjectNode child : children) {</span>
<span class="nc" id="L231">         ProjectNode found = child.findNode(type);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">         if (found != null) {</span>
<span class="nc" id="L233">           return found;</span>
         }
<span class="nc" id="L235">       }</span>
     }

<span class="nc" id="L238">     return null;</span>
   }

  /**
   * Recursively collects all source nodes.
   *
   * @param bucket  container to collect found source nodes in
   */
  protected void findSourceNodes(List&lt;ProjectNode&gt; bucket) {
<span class="nc bnc" id="L247" title="All 2 branches missed.">    if (children != null) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      for (ProjectNode child : children) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (child.isSourceNode()) {</span>
<span class="nc" id="L250">          bucket.add(child);</span>
        }
<span class="nc" id="L252">        child.findSourceNodes(bucket);</span>
<span class="nc" id="L253">      }</span>
    }
<span class="nc" id="L255">  }</span>

  /**
   * Used to rename a node.
   *
   * &lt;p&gt;Note that this will not cause a rename in the storage system!
   *
   * @param newName  new name
   */
  public void setName(String newName) {
<span class="nc" id="L265">    name = newName;</span>
<span class="nc" id="L266">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>