<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Properties.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.properties</a> &gt; <span class="el_source">Properties.java</span></div><h1>Properties.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.properties;

import com.google.appinventor.client.output.OdeLog;
import com.google.appinventor.shared.properties.json.JSONObject;
import com.google.appinventor.shared.properties.json.JSONValue;

import java.util.Comparator;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Collection of properties.
 *
 */
public class Properties&lt;T extends Property&gt; implements Iterable&lt;T&gt; {

  // We define our own special comparator here. It turns out that
  // properties are displayed in the properties panel based on the order
  // they are pulled out of the map. When we used a hashmap, the height
  // and width properties appeared together (lucky I guess). When
  // we replaced it with a TreeMap, properties now appear in the panel
  // in sort order (based on their English names). This separated
  // the heigth and width proprites. This comparator arranges for
  // &quot;Width&quot; to be sorted immediately after &quot;Height.&quot; So properties
  // are now displayed in sort order, with this notable exception, the
  // width property now appears immediately after the Height property
  // which is what people have grown used to (and seems correct).
<span class="nc" id="L35">  private class Comparer implements Comparator&lt;String&gt; {</span>
    public int compare(String a, String b) {
<span class="nc bnc" id="L37" title="All 2 branches missed.">      if (a.equals(&quot;Width&quot;))</span>
<span class="nc" id="L38">        a = &quot;Heightz&quot;;</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">      if (b.equals(&quot;Width&quot;))</span>
<span class="nc" id="L40">        b = &quot;Heightz&quot;;</span>
<span class="nc" id="L41">      return a.compareTo(b);</span>
    }
  }

  // Maps property names to properties
  private final Map&lt;String, T&gt; propertiesMap;

  /**
   * Creates a new properties instance.
   */
<span class="nc" id="L51">  public Properties() {</span>
    // Note: We used to use a HashMap here. However when we iterate over its
    //       contents we get the keys in an arbitrary order based on the hash
    //       implementation. We have had at least one case where an update of
    //       the GWT library changed the order which triggered unanticipated
    //       bugs. By using a TreeMap we will get the keys in a consistent order
<span class="nc" id="L57">    propertiesMap = new TreeMap&lt;String, T&gt;(new Comparer());</span>
<span class="nc" id="L58">  }</span>

  /**
   * Changes the properties from an encoded string of properties.
   *
   * @param propertiesObject  JSON encoded properties
   */
  public void changeProperties(JSONObject propertiesObject) {
<span class="nc" id="L66">    Map&lt;String, JSONValue&gt; properties = propertiesObject.getProperties();</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    for (String name : properties.keySet()) {</span>
<span class="nc" id="L68">      changePropertyValue(name, properties.get(name).asString().getString());</span>
<span class="nc" id="L69">    }</span>
<span class="nc" id="L70">  }</span>

  /**
   * Encodes properties whose value is different from their default value or
   * as a JSON string.
   *
   * @return  encoded properties
   */
  public final String encodeAsJsonString() {
<span class="nc" id="L79">    return '{' + encodeAsPairs(false) + '}';</span>
  }

  /**
   * Encodes all properties as a JSON string.
   *
   * @return  encoded properties
   */
  public final String encodeAllAsJsonString() {
<span class="nc" id="L88">    return '{' + encodeAllAsPairs() + '}';</span>
  }

  /**
   * Encodes properties whose value is different from their default value
   * as JSON pairs.
   *
   * @return  encoded properties
   */
  public String encodeAsPairs(boolean forYail) {
<span class="nc" id="L98">    return encode(forYail, false);</span>
  }

  /**
   * Encodes all properties as JSON pairs.
   *
   * @return  encoded properties
   */
  public String encodeAllAsPairs() {
<span class="nc" id="L107">    return encode(true, true);</span>
  }

  /**
   * Encodes properties as JSON pairs.
   *
   * @param all  indicates whether all persistable properties should be encoded
   *             or only those that have value different from their default
   *             value
   * @return  encoded property pairs
   */
  protected String encode(boolean forYail, boolean all) {
<span class="nc" id="L119">    StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L121">    sb.append(getPrefix());</span>

<span class="nc" id="L123">    String separator = &quot;&quot;;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    for (Property property : this) {</span>
      // Don't encode non-persistable properties or properties being assigned their default value
      // unless encoding for all properties was explicitly requested
<span class="nc bnc" id="L127" title="All 8 branches missed.">      if ((property.isPersisted() || (property.isYail() &amp;&amp; forYail)) &amp;&amp;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">          (all || !property.getDefaultValue().equals(property.getValue()))) {</span>
<span class="nc" id="L129">        sb.append(separator);</span>
<span class="nc" id="L130">        separator = &quot;,&quot;;</span>
<span class="nc" id="L131">        property.encode(sb);</span>
      }
<span class="nc" id="L133">    }</span>

<span class="nc" id="L135">    sb.append(getSuffix());</span>

<span class="nc" id="L137">    return sb.toString();</span>
  }

  /**
   * Optional prefix to add to encoded properties.
   *
   * @return  prefix
   */
  protected String getPrefix() {
<span class="nc" id="L146">    return &quot;&quot;;</span>
  }

  /**
   * Optional suffix to add to encoded properties.
   *
   * @return  suffix
   */
  protected String getSuffix() {
<span class="nc" id="L155">    return &quot;&quot;;</span>
  }

  /**
   * Adds a new property to the collection.
   * A property of the same name may already exist.
   *
   * @param property  property to be added
   */
  protected void addProperty(T property) {
<span class="nc" id="L165">    T oldProperty = propertiesMap.put(property.getName(), property);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (oldProperty != null) {</span>
<span class="nc" id="L167">      propertiesMap.put(property.getName(), oldProperty);  // restore state</span>
<span class="nc" id="L168">      throw new IllegalStateException(&quot;property already exists: &quot; + property.getName());</span>
    }
<span class="nc" id="L170">  }</span>

  /**
   * Removes a property from the collection
   * The property may not exist in the collection
   *
   * @param propertyName name of the property to be removed
   */
  protected void removeProperty(String propertyName) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (propertiesMap.containsKey(propertyName)) {</span>
<span class="nc" id="L180">      propertiesMap.remove(propertyName);</span>
    }
<span class="nc" id="L182">  }</span>

  /**
   * Deletes all properties.
   */
  public final void deleteAllProperties() {
<span class="nc" id="L188">    propertiesMap.clear();</span>
<span class="nc" id="L189">  }</span>

  /**
   * Changes the value of an existing property.
   *
   * @param name  property name
   * @param value  new property value
   * @return true if the property exists and was changed, false otherwise
   */
  public final boolean changePropertyValue(String name, String value) {
    try {
<span class="nc" id="L200">      getExistingProperty(name).setValue(value);</span>
<span class="nc" id="L201">      return true;</span>
<span class="nc" id="L202">    } catch (IllegalStateException e) {</span>
<span class="nc" id="L203">      OdeLog.wlog(e.toString());</span>
<span class="nc" id="L204">      return false;</span>
    }
  }

  public final boolean hasProperty(String name) {
<span class="nc" id="L209">    return propertiesMap.containsKey(name);</span>
  }

  /**
   * Returns the value of an existing property.
   *
   * @param name  property name
   * @return  value of the property
   * @throws IllegalStateException  if no such property exists
   */
  public final String getPropertyValue(String name) {
<span class="nc" id="L220">    return getExistingProperty(name).getValue();</span>
  }

  /**
   * Returns an Iterator over the properties.
   *
   * @return Property iterator
   */
  @Override
  public final Iterator&lt;T&gt; iterator() {
<span class="nc" id="L230">    return propertiesMap.values().iterator();</span>
  }

  /**
   * Returns the property for the given name,
   * or {@code null} if no such property has been defined.
   *
   * @param name  property name
   */
  public final T getProperty(String name) {
<span class="nc" id="L240">    return propertiesMap.get(name);</span>
  }

  /**
   * Returns the existing property for the given name.
   *
   * @throws IllegalStateException  if no such property exists
   */
  public T getExistingProperty(String name) {
<span class="nc" id="L249">    T property = getProperty(name);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    if (property == null) {</span>
<span class="nc" id="L251">      throw new IllegalStateException(&quot;no such property: &quot; + name);</span>
    }
<span class="nc" id="L253">    return property;</span>
  }

  /**
   * Resets the values of all properties to their default values.
   */
  public final void resetProperties() {
<span class="nc bnc" id="L260" title="All 2 branches missed.">    for (Property property : this) {</span>
<span class="nc" id="L261">      property.resetToDefault();</span>
<span class="nc" id="L262">    }</span>
<span class="nc" id="L263">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>