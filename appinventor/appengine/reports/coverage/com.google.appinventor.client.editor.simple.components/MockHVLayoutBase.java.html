<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MockHVLayoutBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.client.editor.simple.components</a> &gt; <span class="el_source">MockHVLayoutBase.java</span></div><h1>MockHVLayoutBase.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2012 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.client.editor.simple.components;

import static com.google.appinventor.client.Ode.MESSAGES;

import java.util.Map;

import com.google.appinventor.client.ErrorReporter;
import com.google.appinventor.client.output.OdeLog;
import com.google.appinventor.components.common.ComponentConstants;
import com.google.gwt.user.client.DOM;
import com.google.gwt.user.client.Element;



/**
 * A base class for layouts that arrange the children of a container in a single
 * column or a single row.
 *
 * @author markf@google.com (Mark Friedman)
 * @author sharon@google.com (Sharon Perl)
 * @author lizlooney@google.com (Liz Looney)
 * @author hal@mit.edu (Hal Abelson)
 */
abstract class MockHVLayoutBase extends MockLayout {

  // Gap between adjacent components to allow for the insertion divider
  private static final int COMPONENT_SPACING = 5;

  // The color of the insertion divider
  private static final String DIVIDER_COLOR = &quot;#0000ff&quot;;

  private static final int EMPTY_WIDTH = ComponentConstants.EMPTY_HV_ARRANGEMENT_WIDTH;
  private static final int EMPTY_HEIGHT = ComponentConstants.EMPTY_HV_ARRANGEMENT_HEIGHT;

  protected final int orientation;



  // Possible locations for the insertion divider;
  // calculated in layoutContainer.
  private int[] dividerLocations;

  /**
   * The location of the insertion divider that shows where a dragged component
   * that is hovering over this layout's container will be inserted if the
   * component is dropped.
   * &lt;p&gt;
   * Legal values include {@code -1} (divider invisible) and {@code 0} (before
   * the first child) to {@code numChildren} (after the last child).
   */
  private int dividerPos;

  // The DIV element that displays the insertion divider.
  // Is added to the root panel of the associated container.
  private Element dividerElement; // lazily initialized

  // Offset of each child's center along the axis of this layout;
  // calculated in layoutContainer; used to calculate the correct
  // drop location for a component dropped onto this layout's container
  private int[] childMidpoints;

  // constants to indicate horizontal and vertical alignment
<span class="nc" id="L69">  private enum HorizontalAlignment {Left, Center, Right};</span>
  private HorizontalAlignment alignH;

<span class="nc" id="L72">  private enum VerticalAlignment {Top, Center, Bottom};</span>
  private VerticalAlignment alignV;

<span class="nc" id="L75">  private enum Dim { HEIGHT, WIDTH };</span>

  /**
   * Creates a new linear layout with the specified orientation.
   */
<span class="nc" id="L80">  MockHVLayoutBase(int orientation) {</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">    if (orientation != ComponentConstants.LAYOUT_ORIENTATION_VERTICAL &amp;&amp;</span>
        orientation != ComponentConstants.LAYOUT_ORIENTATION_HORIZONTAL) {
<span class="nc" id="L83">      throw new IllegalArgumentException(&quot;Illegal orientation: &quot; + orientation);</span>
    }
<span class="nc" id="L85">    this.orientation = orientation;</span>
<span class="nc" id="L86">    layoutWidth = EMPTY_WIDTH;</span>
<span class="nc" id="L87">    layoutHeight = EMPTY_HEIGHT;</span>
<span class="nc" id="L88">    dividerPos = -1;</span>

    // These initial values are assuming that the default values in ComponentConstants are
    // defined as LEFT and TOP
<span class="nc" id="L92">    alignH = HorizontalAlignment.Left;</span>
<span class="nc" id="L93">    alignV = VerticalAlignment.Top;</span>
<span class="nc" id="L94">  }</span>

  // Divider

  private void ensureDividerInited() {
<span class="nc bnc" id="L99" title="All 2 branches missed.">    if (dividerElement == null) {</span>
<span class="nc" id="L100">      dividerElement = DOM.createDiv();</span>
<span class="nc" id="L101">      DOM.setStyleAttribute(dividerElement, &quot;backgroundColor&quot;, DIVIDER_COLOR);</span>
<span class="nc" id="L102">      setDividerVisible(false);</span>
<span class="nc" id="L103">      DOM.appendChild(container.getRootPanel().getElement(), dividerElement);</span>
    }
<span class="nc" id="L105">  }</span>

  private void setDividerLocation(int dividerPos) {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    if (dividerPos &gt;= dividerLocations.length) {</span>
<span class="nc" id="L109">      throw new IllegalArgumentException(&quot;Illegal dividerPos: &quot; + dividerPos);</span>
    }
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (this.dividerPos != dividerPos) {</span>
<span class="nc" id="L112">      this.dividerPos = dividerPos;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (dividerPos == -1) {</span>
<span class="nc" id="L114">        setDividerVisible(false);</span>
      } else {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) {</span>
<span class="nc" id="L117">          setDividerBoundsAndShow(0, dividerLocations[dividerPos],</span>
<span class="nc" id="L118">              container.getOffsetWidth(), COMPONENT_SPACING);</span>
        } else {
<span class="nc" id="L120">          setDividerBoundsAndShow(dividerLocations[dividerPos], 0,</span>
<span class="nc" id="L121">              COMPONENT_SPACING, container.getOffsetHeight());</span>
        }
      }
    }
<span class="nc" id="L125">  }</span>

  private void setDividerVisible(boolean visible) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">    DOM.setStyleAttribute(dividerElement, &quot;visibility&quot;, visible ? &quot;visible&quot; : &quot;hidden&quot;);</span>
<span class="nc" id="L129">  }</span>

  private void setDividerBoundsAndShow(int x, int y, int width, int height) {
<span class="nc" id="L132">    DOM.setStyleAttribute(dividerElement, &quot;position&quot;, &quot;absolute&quot;);</span>
<span class="nc" id="L133">    DOM.setStyleAttribute(dividerElement, &quot;left&quot;, x + &quot;px&quot;);</span>
<span class="nc" id="L134">    DOM.setStyleAttribute(dividerElement, &quot;top&quot;, y + &quot;px&quot;);</span>
<span class="nc" id="L135">    DOM.setStyleAttribute(dividerElement, &quot;width&quot;, width + &quot;px&quot;);</span>
<span class="nc" id="L136">    DOM.setStyleAttribute(dividerElement, &quot;height&quot;, height + &quot;px&quot;);</span>
<span class="nc" id="L137">    setDividerVisible(true);</span>
<span class="nc" id="L138">  }</span>

  // MockLayout methods

  // NOTE(lizlooney) - layout behavior:

  // The Screen component has a Scrollable property. When the Scrollable property is checked, the
  // Screen component behaves like a VerticalArrangement whose Height property is set to Automatic.
  // When the Scrollable property is not checked, the Screen component behaves like a
  // VerticalArrangement whose Height property is specified in pixels.

  // In a VerticalArrangement, components are arranged along the vertical axis, left-aligned.
  // If a VerticalArrangement's Width property is set to Automatic, the actual width of the
  // arrangement is determined by the widest component whose Width property is not set to Fill
  // Parent. If a VerticalArrangement's Width property is set to Automatic and it contains only
  // components whose Width properties are set to Fill Parent, the actual width of the
  // arrangement is calculated using the automatic widths of the components. If a
  // VerticalArrangement's Width property is set to Automatic and it is empty, the width will be
  // 100.
  // If a VerticalArrangement's Height property is set to Automatic, the actual height of the
  // arrangement is determined by the sum of the heights of the components. If a
  // VerticalArrangement's Height property is set to Automatic, any components whose Height
  // properties are set to Fill Parent will behave as if they were set to Automatic.
  // If a VerticalArrangement's Height property is set to Fill Parent or specified in pixels, any
  // components whose Height properties are set to Fill Parent will equally take up the height not
  // occupied by other components.

  // In a HorizontalArrangement, components are arranged along the horizontal axis, vertically
  // center-aligned, even if the vertical aligned is &quot;top&quot;, in which case they are
  // center-aligned at the top of the arrangement.  This is unlike VerticalArrangement, where
  // the components are flush-left at the left of the arrangement if the horizontal alignment
  // is &quot;left&quot;.

  // If a HorizontalArrangement's Height property is set to Automatic, the actual height of the
  // arrangement is determined by the tallest component whose Height property is not set to Fill
  // Parent. If a HorizontalArrangement's Height property is set to Automatic and it contains only
  // components whose Height properties are set to Fill Parent, the actual height of the
  // arrangement is calculated using the automatic heights of the components. If a
  // HorizontalArrangement's Height property is set to Automatic and it is empty, the height will be
  // 100.
  // If a HorizontalArrangement's Width property is set to Automatic, the actual width of the
  // arrangement is determined by the sum of the widths of the components. If a
  // HorizontalArrangement's Width property is set to Automatic, any components whose Width
  // properties are set to Fill Parent will behave as if they were set to Automatic.
  // If a HorizontalArrangement's Width property is set to Fill Parent or specified in pixels, any
  // components whose Width properties are set to Fill Parent will equally take up the width not
  // occupied by other components.

  @Override
  LayoutInfo createContainerLayoutInfo(Map&lt;MockComponent, LayoutInfo&gt; layoutInfoMap) {
<span class="nc" id="L188">    ensureDividerInited();</span>

<span class="nc" id="L190">    return new LayoutInfo(layoutInfoMap, container) {</span>
      @Override
      void calculateAndStoreAutomaticWidth() {
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (orientation == ComponentConstants.LAYOUT_ORIENTATION_HORIZONTAL) {</span>
          // In a HorizontalArrangement whose width is automatic, a child whose width is fill
          // parent will behave as if it were automatic.
<span class="nc bnc" id="L196" title="All 2 branches missed.">          for (MockComponent child : visibleChildren) {</span>
<span class="nc" id="L197">            LayoutInfo childLayoutInfo = layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (childLayoutInfo.width == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L199">              childLayoutInfo.calculateAndStoreAutomaticWidth();</span>
            }
<span class="nc" id="L201">          }</span>
        }
<span class="nc" id="L203">        super.calculateAndStoreAutomaticWidth();</span>
<span class="nc" id="L204">      }</span>

      @Override
      void calculateAndStoreAutomaticHeight() {
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) {</span>
          // In a VerticalArrangement whose height is automatic, a child whose height is fill
          // parent will behave as if it were automatic.
<span class="nc bnc" id="L211" title="All 2 branches missed.">          for (MockComponent child : visibleChildren) {</span>
<span class="nc" id="L212">            LayoutInfo childLayoutInfo = layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (childLayoutInfo.height == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L214">              childLayoutInfo.calculateAndStoreAutomaticHeight();</span>
            }
<span class="nc" id="L216">          }</span>
        }
<span class="nc" id="L218">        super.calculateAndStoreAutomaticHeight();</span>
<span class="nc" id="L219">      }</span>

      @Override
      int calculateAutomaticWidth() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (visibleChildren.isEmpty()) {</span>
<span class="nc" id="L224">          return EMPTY_WIDTH;</span>
        }

<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) {</span>
<span class="nc" id="L228">          return calculateAutomaticWidthVertical(this);</span>
        } else {
<span class="nc" id="L230">          return calculateAutomaticWidthHorizontal(this);</span>
        }
      }

      @Override
      int calculateAutomaticHeight() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (visibleChildren.isEmpty()) {</span>
<span class="nc" id="L237">          return EMPTY_HEIGHT;</span>
        }

<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) {</span>
<span class="nc" id="L241">          return calculateAutomaticHeightVertical(this);</span>
        } else {
<span class="nc" id="L243">          return calculateAutomaticHeightHorizontal(this);</span>
        }
      }
    };
  }

  @Override
  void layoutChildren(LayoutInfo containerLayoutInfo) {
<span class="nc" id="L251">    int visibleChildrenSize = containerLayoutInfo.visibleChildren.size();</span>
<span class="nc" id="L252">    dividerLocations = new int[visibleChildrenSize + 1];</span>
<span class="nc" id="L253">    childMidpoints = new int[visibleChildrenSize];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">    if (visibleChildrenSize &gt; 0) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">      if (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) {</span>
<span class="nc" id="L256">        layoutVertical(containerLayoutInfo);</span>
      } else {
<span class="nc" id="L258">        layoutHorizontal(containerLayoutInfo);</span>
      }
    } else {
<span class="nc" id="L261">      layoutWidth = EMPTY_WIDTH;</span>
<span class="nc" id="L262">      layoutHeight = EMPTY_HEIGHT;</span>
    }
<span class="nc" id="L264">  }</span>

  private int calculateAutomaticWidthVertical(LayoutInfo containerLayoutInfo) {
    // The width will be the widest child, ignoring any child's width that is fill parent.
<span class="nc" id="L268">    boolean allFillParent = true;</span>
<span class="nc" id="L269">    int width = 0;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L271">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (childLayoutInfo.width != MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L273">        width = Math.max(width, childLayoutInfo.width + BORDER_SIZE);</span>
<span class="nc" id="L274">        allFillParent = false;</span>
      }
<span class="nc" id="L276">    }</span>
    // If all children have widths that are fill parent, find the widest child using the
    // automatic widths of the children.
<span class="nc bnc" id="L279" title="All 2 branches missed.">    if (allFillParent) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L281">        LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc" id="L282">        int childWidth = childLayoutInfo.calculateAutomaticWidth();</span>
<span class="nc" id="L283">        width = Math.max(width, childWidth + BORDER_SIZE);</span>
<span class="nc" id="L284">      }</span>
    }
<span class="nc" id="L286">    return width;</span>
  }

  private int calculateAutomaticHeightVertical(LayoutInfo containerLayoutInfo) {
    // The height will be the sum of the child heights.
<span class="nc" id="L291">    int height = 0;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L293">      height += COMPONENT_SPACING;</span>
<span class="nc" id="L294">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
      // If the height is fill parent, use automatic height.
<span class="nc" id="L296">      int childHeight = childLayoutInfo.height;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      if (childHeight == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L298">        childHeight = childLayoutInfo.calculateAutomaticHeight();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">      } else if (childHeight &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG) {</span>
<span class="nc" id="L300">        childHeight = convertFromPercent(childHeight, Dim.HEIGHT);</span>
      }
<span class="nc" id="L302">      height += childHeight + BORDER_SIZE;</span>
<span class="nc" id="L303">    }</span>
<span class="nc" id="L304">    height += COMPONENT_SPACING;</span>
<span class="nc" id="L305">    return height;</span>
  }

  private void layoutVertical(LayoutInfo containerLayoutInfo) {
    // Components are arranged along the vertical axis.  They are left-justified and
    // at the top of the arrangement by default, but this can be changed with the
    // contentCentering property.  Note that the screen itself does a vertical layout

    // Calculate the height used up by children whose height is not fill parent.
    // NOTE(halabelson) Here and in calculateAutomaticHeightVertical, we're putting
    // COMPONENT_SPACING above the first child and below the last child.  We probably don't
    // really want to do this, but need to think about it.
<span class="nc" id="L317">    int usedHeight = 0;</span>
<span class="nc" id="L318">    int countFillParent = 0;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L320">      usedHeight += COMPONENT_SPACING;</span>
<span class="nc" id="L321">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc" id="L322">      int childHeight = childLayoutInfo.height;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (childHeight &lt; MockVisibleComponent.LENGTH_PERCENT_TAG)</span>
<span class="nc" id="L324">        childHeight = convertFromPercent(childHeight, Dim.HEIGHT);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">      if (childHeight == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L326">        countFillParent++;</span>
      } else {
<span class="nc" id="L328">        usedHeight += childHeight + BORDER_SIZE;</span>
      }
<span class="nc" id="L330">    }</span>
<span class="nc" id="L331">    usedHeight += COMPONENT_SPACING;</span>

    // The remaining height, after allocating vertical space for the contents
<span class="nc" id="L334">    int remainingHeight = containerLayoutInfo.height - usedHeight;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (remainingHeight &lt; 0) {</span>
<span class="nc" id="L336">      remainingHeight = 0;</span>
    }

    // The final remaining height, which will be zero if any of the components have height
    // fill-parent
<span class="nc" id="L341">   int finalRemainingHeight = remainingHeight;</span>

    // Resolve any child's width or height that is fill-parent, and call layoutChildren for
    // children that are containers.
<span class="nc bnc" id="L345" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L346">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">      if (childLayoutInfo.width == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L348">        childLayoutInfo.width = containerLayoutInfo.width - BORDER_SIZE;</span>
      }
<span class="nc bnc" id="L350" title="All 2 branches missed.">      if (childLayoutInfo.width &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG) {</span>
<span class="nc" id="L351">        childLayoutInfo.width = convertFromPercent(childLayoutInfo.width, Dim.WIDTH);</span>
      }
<span class="nc bnc" id="L353" title="All 2 branches missed.">      if (childLayoutInfo.height == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L354">        childLayoutInfo.height = remainingHeight / countFillParent - BORDER_SIZE;</span>
        // if any component has height fill-parent then there's no remaining height
<span class="nc" id="L356">        finalRemainingHeight = 0;</span>
      }
<span class="nc bnc" id="L358" title="All 2 branches missed.">      if (childLayoutInfo.height &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG) {</span>
<span class="nc" id="L359">        childLayoutInfo.height = convertFromPercent(childLayoutInfo.height, Dim.HEIGHT);</span>
      }

      // If the child is a container call layoutChildren for it.
<span class="nc bnc" id="L363" title="All 2 branches missed.">      if (child instanceof MockContainer) {</span>
<span class="nc" id="L364">        ((MockContainer) child).getLayout().layoutChildren(childLayoutInfo);</span>
      }
<span class="nc" id="L366">    }</span>

    // topY is where the top of each component goes.  It starts out either at zero, or offset
    // so the entire stack is vertically centered in the arrangement (i.e., offset by
    // finalRemainingHeight/2) or offset so that the bottom of the stack of components is at
    // the bottom of the layout (i.e., offset by finalRemainingHeight).
<span class="nc" id="L372">    int topY = 0;</span>

<span class="nc bnc" id="L374" title="All 4 branches missed.">    switch (alignV) {</span>
    case Top:
<span class="nc" id="L376">      topY = 0;</span>
<span class="nc" id="L377">      break;</span>
    case Center:
<span class="nc" id="L379">      topY = finalRemainingHeight / 2;</span>
<span class="nc" id="L380">      break;</span>
    case Bottom:
<span class="nc" id="L382">      topY = finalRemainingHeight;</span>
<span class="nc" id="L383">      break;</span>
    default:
<span class="nc" id="L385">      OdeLog.elog(&quot;System error: Bad value for vertical alignment -- MockHVLayoutBase&quot;);</span>
    }

<span class="nc" id="L388">    int index = 0;</span>

    // Position the children and update layoutWidth and layoutHeight.

    // NOTE(halabelson)  What is this for?
<span class="nc" id="L393">    layoutWidth = 0;</span>

    // iterate through the children, setting the leftX and topY positions

<span class="nc bnc" id="L397" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L398">      dividerLocations[index] = topY;</span>
<span class="nc" id="L399">      topY += COMPONENT_SPACING;</span>

<span class="nc" id="L401">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc" id="L402">      int childWidthWithBorder = childLayoutInfo.width + BORDER_SIZE;</span>
<span class="nc" id="L403">      int childHeightWithBorder = childLayoutInfo.height + BORDER_SIZE;</span>

      // leftX is where the left edge of the child should be.  For a vertical alignment
      // it's either zero (left align) or set so the center of child is at the centered
      // (center-align) or set so the right edge of the child is at the right edge of the
      // layout (right-align).
<span class="nc" id="L409">      int leftX = 0;</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">      switch (alignH) {</span>
      case Left:
<span class="nc" id="L412">        leftX = 0;</span>
<span class="nc" id="L413">        break;</span>
      case Center:
<span class="nc" id="L415">        leftX = (containerLayoutInfo.width - childWidthWithBorder) / 2 ;</span>
<span class="nc" id="L416">        break;</span>
      case Right:
<span class="nc" id="L418">        leftX = containerLayoutInfo.width - childWidthWithBorder;</span>
<span class="nc" id="L419">        break;</span>
      default:
<span class="nc" id="L421">        OdeLog.elog(&quot;System error: Bad value for horizontal alignment -- MockHVLayoutBase&quot;);</span>
      }

<span class="nc" id="L424">      container.setChildSizeAndPosition(child, childLayoutInfo, leftX, topY);</span>
<span class="nc" id="L425">      childMidpoints[index] = topY + (childHeightWithBorder / 2);</span>
<span class="nc" id="L426">      topY += childHeightWithBorder;</span>
<span class="nc" id="L427">      index++;</span>
<span class="nc" id="L428">    }</span>
<span class="nc" id="L429">    dividerLocations[index] = topY;</span>
<span class="nc" id="L430">    topY += COMPONENT_SPACING;</span>
<span class="nc" id="L431">    layoutHeight = topY;</span>
<span class="nc" id="L432">  }</span>

  private int calculateAutomaticHeightHorizontal(LayoutInfo containerLayoutInfo) {
    // The height will be the tallest child, ignoring any child's height that is fill parent.
<span class="nc" id="L436">    boolean allFillParent = true;</span>
<span class="nc" id="L437">    int height = 0;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L439">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (childLayoutInfo.height != MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L441">        height = Math.max(height, childLayoutInfo.height + BORDER_SIZE);</span>
<span class="nc" id="L442">        allFillParent = false;</span>
      }
<span class="nc" id="L444">    }</span>
    // If all children have heights that are fill parent, find the tallest child using the
    // automatic heights of the children.
<span class="nc bnc" id="L447" title="All 2 branches missed.">    if (allFillParent) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">      for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L449">        LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc" id="L450">        int childHeight = childLayoutInfo.calculateAutomaticHeight();</span>
<span class="nc" id="L451">        height = Math.max(height, childHeight + BORDER_SIZE);</span>
<span class="nc" id="L452">      }</span>
    }
<span class="nc" id="L454">    return height;</span>
  }

  // TODO: (hal)  This next method is incorrect because the width need to be constrained by
  // the room remaining in the parent container.  The overall automatic layout algorithms
  // need to be reviewed.

  private int calculateAutomaticWidthHorizontal(LayoutInfo containerLayoutInfo) {
    // The width will be the sum of the child widths.
<span class="nc" id="L463">    int width = 0;</span>
<span class="nc" id="L464">    boolean firstChild = true;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
      // add spacing, but not before first child
<span class="nc bnc" id="L467" title="All 2 branches missed.">      if (firstChild) {</span>
<span class="nc" id="L468">        firstChild = false;</span>
      } else {
<span class="nc" id="L470">        width += COMPONENT_SPACING;</span>
      }
<span class="nc" id="L472">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
      // If the width is fill parent, use automatic width.
<span class="nc" id="L474">      int childWidth = childLayoutInfo.width;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      if (childWidth &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG)</span>
<span class="nc" id="L476">        childWidth = convertFromPercent(childWidth, Dim.WIDTH);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">      childWidth = (childLayoutInfo.width == MockVisibleComponent.LENGTH_FILL_PARENT)</span>
<span class="nc" id="L478">        ? childLayoutInfo.calculateAutomaticWidth()</span>
        : childWidth;
<span class="nc" id="L480">      width += childWidth + BORDER_SIZE;</span>
<span class="nc" id="L481">    }</span>
<span class="nc" id="L482">    return width;</span>
  }

  // TODO(hal): Check this to see if we're putting the component vertical spacing in the right
  // places and think about rewriting this to match how layoutHorizontal handles width.

  private void layoutHorizontal(LayoutInfo containerLayoutInfo) {
    // Children are arranged along the horizontal axis.   They are
    // and vertically center-aligned at the top of the arrangement by default, and at vertical
    // center of the arrangement if vertical contentCentering is specified.
    // Horizontally, they can be left-aligned, centered, or right-aligned.
<span class="nc" id="L493">    int usedWidth = 0;</span>
<span class="nc" id="L494">    boolean firstChild = true;</span>
<span class="nc" id="L495">    int countFillParent = 0;</span>

    // Calculate the width used up by children whose width is not fill parent.
    // Include spacing between the children
<span class="nc bnc" id="L499" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
      // add spacing, but not before first child
<span class="nc bnc" id="L501" title="All 2 branches missed.">      if (firstChild) {</span>
<span class="nc" id="L502">        firstChild = false;</span>
      } else {
<span class="nc" id="L504">        usedWidth += COMPONENT_SPACING;</span>
      }
<span class="nc" id="L506">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">      if (childLayoutInfo.width &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG)</span>
<span class="nc" id="L508">        childLayoutInfo.width = convertFromPercent(childLayoutInfo.width, Dim.WIDTH);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">      if (childLayoutInfo.width == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L510">        countFillParent++;</span>
      } else {
<span class="nc" id="L512">        usedWidth += childLayoutInfo.width + BORDER_SIZE;</span>
      }
<span class="nc" id="L514">    }</span>

    // The remaining width, after allocating horizontal space for the
    // contents, not counting the width of fill-parent children
    // If there are fill-parent children, this remaining width will be
    // divided equally among them.
<span class="nc" id="L520">    int remainingWidth = containerLayoutInfo.width - usedWidth;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (remainingWidth &lt; 0) {</span>
<span class="nc" id="L522">      remainingWidth = 0;</span>
    }

    // The final remaining width after all children have been accounted for.  This will be 0 if
    // any of the children have width fill-parent
<span class="nc" id="L527">    int finalRemainingWidth = remainingWidth;</span>

    // Resolve any child's width or height that is fill parent, and call layoutChildren for
    // children that are containers.
    // Figure out the height of the largest child so we can middle-align all the children.
    // Note that layoutVertical does not do the analogous center aligning unless horizontal
    // centering is explicitly specified.
<span class="nc" id="L534">    int maxHeight = 0;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
<span class="nc" id="L536">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (childLayoutInfo.width == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
        // at this point, remaining width is too small and gets smaller if there
        // are more components
<span class="nc" id="L540">        childLayoutInfo.width = remainingWidth / countFillParent - BORDER_SIZE;</span>
        // if any component has width fill parent then there will be no final remaining width
<span class="nc" id="L542">        finalRemainingWidth = 0;</span>
      }

<span class="nc bnc" id="L545" title="All 2 branches missed.">      if (childLayoutInfo.height == MockVisibleComponent.LENGTH_FILL_PARENT) {</span>
<span class="nc" id="L546">        childLayoutInfo.height = containerLayoutInfo.height - BORDER_SIZE;</span>
      }

<span class="nc bnc" id="L549" title="All 2 branches missed.">      if (childLayoutInfo.height &lt;= MockVisibleComponent.LENGTH_PERCENT_TAG)</span>
<span class="nc" id="L550">        childLayoutInfo.height = convertFromPercent(childLayoutInfo.height, Dim.HEIGHT);</span>

<span class="nc" id="L552">      maxHeight = Math.max(maxHeight, childLayoutInfo.height + BORDER_SIZE);</span>

      // If the child is a container then call layoutChildren for it.
<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (child instanceof MockContainer) {</span>
<span class="nc" id="L556">        ((MockContainer) child).getLayout().layoutChildren(childLayoutInfo);</span>
      }
<span class="nc" id="L558">    }</span>

    // NOTE(hal) What is this for?
<span class="nc" id="L561">    layoutHeight = 0;</span>

    // Now we've computed the actual widths of the components, so we can lay them out.

    // leftX is where the left edge of the next child should be.  For a horizontal alignment
    // leftX starts out either at zero (left align) or set so the center of the arrangement
    // is at the center of the layout (center-align) or set so the right edge of the arrangement
    // child is at the right edge of the layout (right-align).
<span class="nc" id="L569">    int leftX = 0;</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">    switch (alignH) {</span>
    case Left:
<span class="nc" id="L572">      leftX = 0;</span>
<span class="nc" id="L573">      break;</span>
    case Center:
<span class="nc" id="L575">      leftX = finalRemainingWidth / 2;</span>
<span class="nc" id="L576">      break;</span>
    case Right:
<span class="nc" id="L578">      leftX = finalRemainingWidth;</span>
<span class="nc" id="L579">      break;</span>
    default:
<span class="nc" id="L581">      OdeLog.elog(&quot;System error: Bad value for horizontal justification -- MockHVLayoutBase&quot;);</span>
    }

    // Position each child and update layoutWidth and layoutHeight.
<span class="nc" id="L585">    int index = 0;</span>
<span class="nc" id="L586">    firstChild = true;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">    for (MockComponent child : containerLayoutInfo.visibleChildren) {</span>
      // add spacing, but not before first child
<span class="nc bnc" id="L589" title="All 2 branches missed.">      if (firstChild) {</span>
<span class="nc" id="L590">        firstChild = false;</span>
      } else {
<span class="nc" id="L592">        leftX += COMPONENT_SPACING;</span>
      }
<span class="nc" id="L594">      dividerLocations[index] = leftX;</span>
<span class="nc" id="L595">      LayoutInfo childLayoutInfo = containerLayoutInfo.layoutInfoMap.get(child);</span>
<span class="nc" id="L596">      int childWidthWithBorder = childLayoutInfo.width + BORDER_SIZE;</span>
<span class="nc" id="L597">      int childHeightWithBorder = childLayoutInfo.height + BORDER_SIZE;</span>

      // topY is where the top of each component goes.  It starts out either at zero, or offset
      // so the entire stack is vertically centered in the arrangement (i.e., offset by
      // (containerLayoutInfo.height / 2) - (childHeightWithBorder / 2)) or offset so that
      // the bottom of the stack of components is at the bottom of the layout
      // (i.e., offset by containerLayoutInfo.height - childHeightWithBorder).
<span class="nc" id="L604">      int topY = 0;</span>

<span class="nc bnc" id="L606" title="All 4 branches missed.">      switch (alignV) {</span>
        case Top:
<span class="nc" id="L608">          topY = 0;</span>
<span class="nc" id="L609">          break;</span>
        case Center:
<span class="nc" id="L611">          topY = (containerLayoutInfo.height / 2) - (childHeightWithBorder / 2);</span>
<span class="nc" id="L612">          break;</span>
        case Bottom:
<span class="nc" id="L614">          topY = containerLayoutInfo.height - childHeightWithBorder;</span>
        default:
<span class="nc" id="L616">          OdeLog.elog(&quot;System error: Bad value for vertical alignment -- MockHVLayoutBase&quot;);</span>
      }

<span class="nc" id="L619">      container.setChildSizeAndPosition(child, childLayoutInfo, leftX, topY);</span>
<span class="nc" id="L620">      layoutHeight = Math.max(layoutHeight, topY + childHeightWithBorder);</span>
<span class="nc" id="L621">      childMidpoints[index] = leftX + (childWidthWithBorder / 2);</span>
<span class="nc" id="L622">      leftX += childWidthWithBorder;</span>
<span class="nc" id="L623">      index++;</span>
<span class="nc" id="L624">    }</span>
<span class="nc" id="L625">    dividerLocations[index] = leftX;</span>
<span class="nc" id="L626">    layoutWidth = leftX;</span>
<span class="nc" id="L627">  }</span>

  @Override
  void onDragContinue(int x, int y) {
<span class="nc bnc" id="L631" title="All 2 branches missed.">    if (childMidpoints != null) {</span>
      // Calculate the position where the hovering component should be inserted
<span class="nc" id="L633">      int insertPos = -1;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">      int dropOffset = (orientation == ComponentConstants.LAYOUT_ORIENTATION_VERTICAL) ? y : x;</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">      for (int i = 0; i &lt; childMidpoints.length; i++) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (dropOffset &lt;= childMidpoints[i]) {</span>
<span class="nc" id="L637">          insertPos = i;</span>
<span class="nc" id="L638">          break;</span>
        }
      }
<span class="nc bnc" id="L641" title="All 2 branches missed.">      if (insertPos == -1) {</span>
<span class="nc" id="L642">        insertPos = childMidpoints.length;</span>
      }

      // Display the divider at the insert location
<span class="nc" id="L646">      setDividerLocation(insertPos);</span>
    }
<span class="nc" id="L648">  }</span>

  @Override
  void onDragLeave() {
    // Hide the divider and clean up
<span class="nc" id="L653">    setDividerLocation(-1);</span>
<span class="nc" id="L654">  }</span>

  @Override
  boolean onDrop(MockComponent source, int x, int y, int offsetX, int offsetY) {
<span class="nc bnc" id="L658" title="All 2 branches missed.">    if (dividerPos != -1) {</span>
<span class="nc" id="L659">      int dstPos = dividerPos;</span>

      // Hide the divider.
<span class="nc" id="L662">      setDividerLocation(-1);</span>

      // Calculate drop information
<span class="nc" id="L665">      MockContainer srcContainer = source.getContainer();</span>
<span class="nc" id="L666">      MockContainer dstContainer = container;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">      if (srcContainer == dstContainer) {</span>
<span class="nc" id="L668">        final int srcPos = srcContainer.getShowingVisibleChildren().indexOf(source);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (dstPos &gt; srcPos) {</span>
          // Compensate the insertion index for the removal of the original
          // component from the same container
<span class="nc" id="L672">          dstPos--;</span>
        }
      }

      // Perform drop
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (srcContainer != null) {</span>
        // Pass false to indicate that the component isn't being permanently deleted.
        // It's just being moved from one container to another.
<span class="nc" id="L680">        srcContainer.removeComponent(source, false);</span>
      }
<span class="nc" id="L682">      dstContainer.addVisibleComponent(source, dstPos);</span>
<span class="nc" id="L683">      return true;</span>
    }
<span class="nc" id="L685">    return false;</span>
  }

  @Override
  void dispose() {
<span class="nc bnc" id="L690" title="All 2 branches missed.">    if (dividerElement != null) {</span>
<span class="nc" id="L691">      DOM.removeChild(container.getRootPanel().getElement(), dividerElement);</span>
    }
<span class="nc" id="L693">  }</span>

  /**
   * Set the layout flags centerH and centerV that govern whether the layout performs
   * horizontal or vertical centering.   Called by the arrangement that uses this layout
   * @param centering is the string value of the centering property &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, or &quot;3&quot;
   */


  public void setHAlignmentFlags(String alignment) {
    try {
<span class="nc bnc" id="L704" title="All 4 branches missed.">      switch (Integer.parseInt(alignment)) {</span>
      case ComponentConstants.GRAVITY_LEFT:
<span class="nc" id="L706">        alignH = HorizontalAlignment.Left;</span>
<span class="nc" id="L707">        break;</span>
      case ComponentConstants.GRAVITY_CENTER_HORIZONTAL:
<span class="nc" id="L709">        alignH = HorizontalAlignment.Center;</span>
<span class="nc" id="L710">        break;</span>
      case ComponentConstants.GRAVITY_RIGHT:
<span class="nc" id="L712">        alignH = HorizontalAlignment.Right;</span>
<span class="nc" id="L713">        break;</span>
      default:
        // This error should not happen because the higher level
        // setter for HorizontalAlignment should screen out illegal inputs.
<span class="nc" id="L717">        ErrorReporter.reportError(MESSAGES.badValueForHorizontalAlignment(alignment));</span>
      }
<span class="nc" id="L719">    } catch (NumberFormatException e) {</span>
      // As above, this error should not happen
<span class="nc" id="L721">      ErrorReporter.reportError(MESSAGES.badValueForHorizontalAlignment(alignment));</span>
<span class="nc" id="L722">    }</span>
<span class="nc" id="L723">  }</span>

  public void setVAlignmentFlags(String alignment) {
    try {
<span class="nc bnc" id="L727" title="All 4 branches missed.">      switch (Integer.parseInt(alignment)) {</span>
      case ComponentConstants.GRAVITY_TOP:
<span class="nc" id="L729">        alignV = VerticalAlignment.Top;</span>
<span class="nc" id="L730">        break;</span>
      case ComponentConstants.GRAVITY_CENTER_VERTICAL:
<span class="nc" id="L732">        alignV = VerticalAlignment.Center;</span>
<span class="nc" id="L733">        break;</span>
      case ComponentConstants.GRAVITY_BOTTOM:
<span class="nc" id="L735">        alignV = VerticalAlignment.Bottom;</span>
<span class="nc" id="L736">        break;</span>
      default:
        // This error should not happen because the higher level
        // setter for VerticalAlignment should screen out illegal inputs.
<span class="nc" id="L740">        ErrorReporter.reportError(MESSAGES.badValueForVerticalAlignment(alignment));</span>
      }
<span class="nc" id="L742">    } catch (NumberFormatException e) {</span>
      // As above, this error should not happen
<span class="nc" id="L744">      ErrorReporter.reportError(MESSAGES.badValueForVerticalAlignment(alignment));</span>
<span class="nc" id="L745">    }</span>
<span class="nc" id="L746">  }</span>

  private int convertFromPercent(int childLength, Dim dim) {
<span class="nc" id="L749">    MockForm form = container.getForm();</span>
    int parentLength;
<span class="nc bnc" id="L751" title="All 2 branches missed.">    if (dim == Dim.WIDTH) {</span>
<span class="nc" id="L752">      parentLength = form.screenWidth;</span>
    } else {
<span class="nc" id="L754">      parentLength = form.usableScreenHeight;</span>
    }

<span class="nc bnc" id="L757" title="All 2 branches missed.">    if (childLength &gt; MockVisibleComponent.LENGTH_PERCENT_TAG)</span>
<span class="nc" id="L758">      return childLength;       // Shouldn't happen</span>

<span class="nc" id="L760">    childLength = parentLength * (- (childLength - MockVisibleComponent.LENGTH_PERCENT_TAG)) / 100;</span>
<span class="nc" id="L761">    return childLength;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>