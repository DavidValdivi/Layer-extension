<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>YoungAndroidProjectService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.google.appinventor.server.project.youngandroid</a> &gt; <span class="el_source">YoungAndroidProjectService.java</span></div><h1>YoungAndroidProjectService.java</h1><pre class="source lang-java linenums">// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2009-2011 Google, All Rights reserved
// Copyright 2011-2017 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

package com.google.appinventor.server.project.youngandroid;

import com.google.appengine.api.utils.SystemProperty;
import com.google.apphosting.api.ApiProxy;
import com.google.appinventor.common.utils.StringUtils;
import com.google.appinventor.common.version.GitBuildId;
import com.google.appinventor.components.common.YaVersion;
import com.google.appinventor.server.CrashReport;
import com.google.appinventor.server.FileExporter;
import com.google.appinventor.server.FileExporterImpl;
import com.google.appinventor.server.FileImporter;
import com.google.appinventor.server.FileImporterException;
import com.google.appinventor.server.FileImporterImpl;
import com.google.appinventor.server.Server;
import com.google.appinventor.server.encryption.EncryptionException;
import com.google.appinventor.server.flags.Flag;
import com.google.appinventor.server.project.CommonProjectService;
import com.google.appinventor.server.project.utils.Security;
import com.google.appinventor.server.properties.json.ServerJsonParser;
import com.google.appinventor.server.storage.StorageIo;
import com.google.appinventor.server.util.UriBuilder;
import com.google.appinventor.shared.properties.json.JSONParser;
import com.google.appinventor.shared.rpc.RpcResult;
import com.google.appinventor.shared.rpc.ServerLayout;
import com.google.appinventor.shared.rpc.project.NewProjectParameters;
import com.google.appinventor.shared.rpc.project.Project;
import com.google.appinventor.shared.rpc.project.ProjectNode;
import com.google.appinventor.shared.rpc.project.ProjectRootNode;
import com.google.appinventor.shared.rpc.project.ProjectSourceZip;
import com.google.appinventor.shared.rpc.project.RawFile;
import com.google.appinventor.shared.rpc.project.TextFile;
import com.google.appinventor.shared.rpc.project.UserProject;
import com.google.appinventor.shared.rpc.project.youngandroid.NewYoungAndroidProjectParameters;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidAssetNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidAssetsFolder;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidBlocksNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidComponentNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidComponentsFolder;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidFormNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidPackageNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidProjectNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidSourceFolderNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidSourceNode;
import com.google.appinventor.shared.rpc.project.youngandroid.YoungAndroidYailNode;
import com.google.appinventor.shared.rpc.user.User;
import com.google.appinventor.shared.settings.Settings;
import com.google.appinventor.shared.settings.SettingsConstants;
import com.google.appinventor.shared.storage.StorageUtil;
import com.google.appinventor.shared.youngandroid.YoungAndroidSourceAnalyzer;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import com.google.common.collect.Maps;
import com.google.common.io.CharStreams;
import java.util.Locale;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.net.ConnectException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeSet;
import java.util.logging.Logger;

/**
 * Provides support for Young Android projects.
 *
 * @author lizlooney@google.com (Liz Looney)
 * @author markf@google.com (Mark Friedman)
 */
public final class YoungAndroidProjectService extends CommonProjectService {

<span class="fc" id="L92">  private static final Logger LOG = Logger.getLogger(YoungAndroidProjectService.class.getName());</span>
  private static final int MB = 1024 * 1024;

  // The value of this flag can be changed in appengine-web.xml
<span class="fc" id="L96">  private static final Flag&lt;Boolean&gt; sendGitVersion =</span>
<span class="fc" id="L97">    Flag.createFlag(&quot;build.send.git.version&quot;, true);</span>

<span class="fc" id="L99">  private static final Flag&lt;Integer&gt; MAX_PROJECT_SIZE =</span>
<span class="fc" id="L100">      Flag.createFlag(&quot;project.maxsize&quot;, 30);</span>
  private static final String ERROR_LARGE_PROJECT =
      &quot;Sorry, can't package projects larger than %1$d MB. Yours is %2$3.2f MB.&quot;;

  // Project folder prefixes
  public static final String SRC_FOLDER = YoungAndroidSourceAnalyzer.SRC_FOLDER;
  protected static final String ASSETS_FOLDER = &quot;assets&quot;;
  private static final String EXTERNAL_COMPS_FOLDER = &quot;assets/external_comps&quot;;
  static final String PROJECT_DIRECTORY = &quot;youngandroidproject&quot;;

  // TODO(user) Source these from a common constants library.
  private static final String FORM_PROPERTIES_EXTENSION =
      YoungAndroidSourceAnalyzer.FORM_PROPERTIES_EXTENSION;
  private static final String CODEBLOCKS_SOURCE_EXTENSION =
      YoungAndroidSourceAnalyzer.CODEBLOCKS_SOURCE_EXTENSION;
  private static final String BLOCKLY_SOURCE_EXTENSION =
      YoungAndroidSourceAnalyzer.BLOCKLY_SOURCE_EXTENSION;
  private static final String YAIL_FILE_EXTENSION =
      YoungAndroidSourceAnalyzer.YAIL_FILE_EXTENSION;

  public static final String PROJECT_PROPERTIES_FILE_NAME = PROJECT_DIRECTORY + &quot;/&quot; +
      &quot;project.properties&quot;;

<span class="fc" id="L123">  private static final JSONParser JSON_PARSER = new ServerJsonParser();</span>

  // Build folder path
  private static final String BUILD_FOLDER = &quot;build&quot;;

  public static final String PROJECT_KEYSTORE_LOCATION = &quot;android.keystore&quot;;

  // host[:port] to use for connecting to the build server
<span class="fc" id="L131">  private static final Flag&lt;String&gt; buildServerHost =</span>
<span class="fc" id="L132">      Flag.createFlag(&quot;build.server.host&quot;, &quot;localhost:9990&quot;);</span>
  // host[:port] to use for connecting to the second build server
<span class="fc" id="L134">  private static final Flag&lt;String&gt; buildServerHost2 =</span>
<span class="fc" id="L135">      Flag.createFlag(&quot;build2.server.host&quot;, &quot;&quot;);</span>
  // host[:port] to tell build server app host url
<span class="fc" id="L137">  private static final Flag&lt;String&gt; appengineHost =</span>
<span class="fc" id="L138">      Flag.createFlag(&quot;appengine.host&quot;, &quot;&quot;);</span>
<span class="fc" id="L139">  private static final boolean DEBUG = Flag.createFlag(&quot;appinventor.debugging&quot;, false).get();</span>

<span class="fc" id="L141">  private static final String galleryLocation = Flag.createFlag(&quot;gallery.location&quot;, &quot;http://localhost:9001&quot;).get();</span>
<span class="fc" id="L142">  private static final String galleryId = Flag.createFlag(&quot;gallery.id&quot;, &quot;&quot;).get();</span>

  public YoungAndroidProjectService(StorageIo storageIo) {
<span class="fc" id="L145">    super(YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE, storageIo);</span>
<span class="fc" id="L146">  }</span>

  /**
   * Returns the contents of a new Young Android form file.
   * @param qualifiedName the qualified name of the form.
   * @return the contents of a new Young Android form file.
   */
  @VisibleForTesting
  public static String getInitialFormPropertiesFileContents(String qualifiedName) {
<span class="fc" id="L155">    final int lastDotPos = qualifiedName.lastIndexOf('.');</span>
<span class="fc" id="L156">    String packageName = qualifiedName.split(&quot;\\.&quot;)[2];</span>
<span class="fc" id="L157">    String formName = qualifiedName.substring(lastDotPos + 1);</span>
    // The initial Uuid is set to zero here since (as far as we know) we can't get random numbers
    // in ode.shared.  This shouldn't actually matter since all Uuid's are random int's anyway (and
    // 0 was randomly chosen, I promise).  The TODO(user) in MockComponent.java indicates that
    // there will someday be assurance that these random Uuid's are unique.  Once that happens
    // this will be perfectly acceptable.  Until that happens, choosing 0 is just as safe as
    // allowing a random number to be chosen when the MockComponent is first created.
<span class="fc" id="L164">    return &quot;#|\n$JSON\n&quot; +</span>
        &quot;{\&quot;authURL\&quot;:[],&quot; +
        &quot;\&quot;YaVersion\&quot;:\&quot;&quot; + YaVersion.YOUNG_ANDROID_VERSION + &quot;\&quot;,\&quot;Source\&quot;:\&quot;Form\&quot;,&quot; +
        &quot;\&quot;Properties\&quot;:{\&quot;$Name\&quot;:\&quot;&quot; + formName + &quot;\&quot;,\&quot;$Type\&quot;:\&quot;Form\&quot;,&quot; +
        &quot;\&quot;$Version\&quot;:\&quot;&quot; + YaVersion.FORM_COMPONENT_VERSION + &quot;\&quot;,\&quot;Uuid\&quot;:\&quot;&quot; + 0 + &quot;\&quot;,&quot; +
        &quot;\&quot;Title\&quot;:\&quot;&quot; + formName + &quot;\&quot;,\&quot;AppName\&quot;:\&quot;&quot; + packageName +&quot;\&quot;}}\n|#&quot;;
  }

  /**
   * Returns the initial contents of a Young Android blockly blocks file.
   */
  private static String getInitialBlocklySourceFileContents(String qualifiedName) {
<span class="fc" id="L176">    return &quot;&quot;;</span>
  }

  private static String packageNameToPath(String packageName) {
<span class="fc" id="L180">    return SRC_FOLDER + '/' + packageName.replace('.', '/');</span>
  }

  public static String getSourceDirectory(String qualifiedName) {
<span class="fc" id="L184">    return StorageUtil.dirname(packageNameToPath(qualifiedName));</span>
  }

  // CommonProjectService implementation

  @Override
  public void storeProjectSettings(String userId, long projectId, String projectSettings) {
<span class="fc" id="L191">    super.storeProjectSettings(userId, projectId, projectSettings);</span>

    // If the icon has been changed, update the project properties file.
    // Extract the new icon from the projectSettings parameter.
<span class="fc" id="L195">    Settings settings = new Settings(JSON_PARSER, projectSettings);</span>
<span class="fc" id="L196">    YoungAndroidSettingsBuilder newProperties = new YoungAndroidSettingsBuilder(settings);</span>

    // Extract the old icon from the project.properties file from storageIo.
<span class="fc" id="L199">    String projectProperties = storageIo.downloadFile(userId, projectId,</span>
        PROJECT_PROPERTIES_FILE_NAME, StorageUtil.DEFAULT_CHARSET);
<span class="fc" id="L201">    Properties properties = new Properties();</span>
    try {
<span class="fc" id="L203">      properties.load(new StringReader(projectProperties));</span>
<span class="nc" id="L204">    } catch (IOException e) {</span>
      // Since we are reading from a String, I don't think this exception can actually happen.
<span class="nc" id="L206">      e.printStackTrace();</span>
<span class="nc" id="L207">      return;</span>
<span class="fc" id="L208">    }</span>
<span class="fc" id="L209">    YoungAndroidSettingsBuilder oldProperties = new YoungAndroidSettingsBuilder(properties);</span>


<span class="pc bpc" id="L212" title="1 of 2 branches missed.">    if (!oldProperties.equals(newProperties)) {</span>
      // Recreate the project.properties and upload it to storageIo.
<span class="fc" id="L214">      String projectName = properties.getProperty(&quot;name&quot;);</span>
<span class="fc" id="L215">      String qualifiedName = properties.getProperty(&quot;main&quot;);</span>
<span class="fc" id="L216">      String newContent = newProperties.setProjectName(projectName)</span>
<span class="fc" id="L217">          .setQualifiedFormName(qualifiedName).toProperties();</span>
<span class="fc" id="L218">      storageIo.uploadFileForce(projectId, PROJECT_PROPERTIES_FILE_NAME, userId,</span>
          newContent, StorageUtil.DEFAULT_CHARSET);
    }
<span class="fc" id="L221">  }</span>

  /**
   * {@inheritDoc}
   *
   * {@code params} needs to be an instance of
   * {@link NewYoungAndroidProjectParameters}.
   */
  @Override
  public long newProject(String userId, String projectName, NewProjectParameters params) {
<span class="fc" id="L231">    NewYoungAndroidProjectParameters youngAndroidParams = (NewYoungAndroidProjectParameters) params;</span>
<span class="fc" id="L232">    String qualifiedFormName = youngAndroidParams.getQualifiedFormName();</span>

<span class="fc" id="L234">    YoungAndroidSettingsBuilder builder = new YoungAndroidSettingsBuilder()</span>
<span class="fc" id="L235">        .setProjectName(projectName)</span>
<span class="fc" id="L236">        .setQualifiedFormName(qualifiedFormName);</span>
<span class="fc" id="L237">    String propertiesFileContents = builder.toProperties();</span>

<span class="fc" id="L239">    String formFileName = YoungAndroidFormNode.getFormFileId(qualifiedFormName);</span>
<span class="fc" id="L240">    String formFileContents = getInitialFormPropertiesFileContents(qualifiedFormName);</span>

<span class="fc" id="L242">    String blocklyFileName = YoungAndroidBlocksNode.getBlocklyFileId(qualifiedFormName);</span>
<span class="fc" id="L243">    String blocklyFileContents = getInitialBlocklySourceFileContents(qualifiedFormName);</span>

<span class="fc" id="L245">    String yailFileName = YoungAndroidYailNode.getYailFileId(qualifiedFormName);</span>
<span class="fc" id="L246">    String yailFileContents = &quot;&quot;;</span>

<span class="fc" id="L248">    Project project = new Project(projectName);</span>
<span class="fc" id="L249">    project.setProjectType(YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE);</span>
    // Project history not supported in legacy ode new project wizard
<span class="fc" id="L251">    project.addTextFile(new TextFile(PROJECT_PROPERTIES_FILE_NAME, propertiesFileContents));</span>
<span class="fc" id="L252">    project.addTextFile(new TextFile(formFileName, formFileContents));</span>
<span class="fc" id="L253">    project.addTextFile(new TextFile(blocklyFileName, blocklyFileContents));</span>
<span class="fc" id="L254">    project.addTextFile(new TextFile(yailFileName, yailFileContents));</span>

    // Create new project
<span class="fc" id="L257">    return storageIo.createProject(userId, project, builder.build());</span>
  }

  @Override
  public long copyProject(String userId, long oldProjectId, String newName) {
<span class="fc" id="L262">    String oldName = storageIo.getProjectName(userId, oldProjectId);</span>
<span class="fc" id="L263">    String oldProjectSettings = storageIo.loadProjectSettings(userId, oldProjectId);</span>
<span class="fc" id="L264">    String oldProjectHistory = storageIo.getProjectHistory(userId, oldProjectId);</span>
<span class="fc" id="L265">    YoungAndroidSettingsBuilder builder = new YoungAndroidSettingsBuilder(</span>
        new Settings(JSON_PARSER, oldProjectSettings));

<span class="fc" id="L268">    Project newProject = new Project(newName);</span>
<span class="fc" id="L269">    newProject.setProjectType(YoungAndroidProjectNode.YOUNG_ANDROID_PROJECT_TYPE);</span>
<span class="fc" id="L270">    newProject.setProjectHistory(oldProjectHistory);</span>

    // Get the old project's source files and add them to new project, modifying where necessary.
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (String oldSourceFileName : storageIo.getProjectSourceFiles(userId, oldProjectId)) {</span>
      String newSourceFileName;

<span class="fc" id="L276">      String newContents = null;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">      if (oldSourceFileName.equals(PROJECT_PROPERTIES_FILE_NAME)) {</span>
        // This is the project properties file. The name of the file doesn't contain the old
        // project name.
<span class="fc" id="L280">        newSourceFileName = oldSourceFileName;</span>
        // For the contents of the project properties file, generate the file with the new project
        // name and qualified name.
<span class="fc" id="L283">        String qualifiedFormName = StringUtils.getQualifiedFormName(</span>
<span class="fc" id="L284">            storageIo.getUser(userId).getUserEmail(), newName);</span>
<span class="fc" id="L285">        builder.setProjectName(newName).setQualifiedFormName(qualifiedFormName);</span>
<span class="fc" id="L286">        newContents = builder.toProperties();</span>
<span class="fc" id="L287">      } else {</span>
        // This is some file other than the project properties file.
        // oldSourceFileName may contain the old project name as a path segment, surrounded by /.
        // Replace the old name with the new name.
<span class="fc" id="L291">        newSourceFileName = StringUtils.replaceLastOccurrence(oldSourceFileName,</span>
            &quot;/&quot; + oldName + &quot;/&quot;, &quot;/&quot; + newName + &quot;/&quot;);
      }

<span class="fc bfc" id="L295" title="All 2 branches covered.">      if (newContents != null) {</span>
        // We've determined (above) that the contents of the file must change for the new project.
        // Use newContents when adding the file to the new project.
<span class="fc" id="L298">        newProject.addTextFile(new TextFile(newSourceFileName, newContents));</span>
      } else {
        // If we get here, we know that the contents of the file can just be copied from the old
        // project. Since it might be a binary file, we copy it as a raw file (that works for both
        // text and binary files).
<span class="fc" id="L303">        byte[] contents = storageIo.downloadRawFile(userId, oldProjectId, oldSourceFileName);</span>
<span class="fc" id="L304">        newProject.addRawFile(new RawFile(newSourceFileName, contents));</span>
      }
<span class="fc" id="L306">    }</span>

    // Create the new project and return the new project's id.
<span class="fc" id="L309">    return storageIo.createProject(userId, newProject, builder.build());</span>
  }

  @Override
  public ProjectRootNode getRootNode(String userId, long projectId) {
    // Create root, assets, and source nodes (they are mocked nodes as they don't really
    // have to exist like this on the file system)
<span class="fc" id="L316">    ProjectRootNode rootNode =</span>
<span class="fc" id="L317">        new YoungAndroidProjectNode(storageIo.getProjectName(userId, projectId),</span>
                                    projectId);
<span class="fc" id="L319">    ProjectNode assetsNode = new YoungAndroidAssetsFolder(ASSETS_FOLDER);</span>
<span class="fc" id="L320">    ProjectNode sourcesNode = new YoungAndroidSourceFolderNode(SRC_FOLDER);</span>
<span class="fc" id="L321">    ProjectNode compsNode = new YoungAndroidComponentsFolder(EXTERNAL_COMPS_FOLDER);</span>

<span class="fc" id="L323">    rootNode.addChild(assetsNode);</span>
<span class="fc" id="L324">    rootNode.addChild(sourcesNode);</span>
<span class="fc" id="L325">    rootNode.addChild(compsNode);</span>

    // Sources contains nested folders that are interpreted as packages
<span class="fc" id="L328">    Map&lt;String, ProjectNode&gt; packagesMap = Maps.newHashMap();</span>

    // Retrieve project information
<span class="fc" id="L331">    List&lt;String&gt; sourceFiles = storageIo.getProjectSourceFiles(userId, projectId);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">    for (String fileId : sourceFiles) {</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">      if (fileId.startsWith(ASSETS_FOLDER + '/')) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (fileId.startsWith(EXTERNAL_COMPS_FOLDER + '/')) {</span>
<span class="nc" id="L335">          compsNode.addChild(new YoungAndroidComponentNode(StorageUtil.basename(fileId), fileId));</span>
        }
        else {
<span class="nc" id="L338">          assetsNode.addChild(new YoungAndroidAssetNode(StorageUtil.basename(fileId), fileId));</span>
        }
<span class="fc bfc" id="L340" title="All 2 branches covered.">      } else if (fileId.startsWith(SRC_FOLDER + '/')) {</span>
        // We send form (.scm), blocks (.blk), and yail (.yail) nodes to the ODE client.
<span class="fc" id="L342">        YoungAndroidSourceNode sourceNode = null;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (fileId.endsWith(FORM_PROPERTIES_EXTENSION)) {</span>
<span class="fc" id="L344">          sourceNode = new YoungAndroidFormNode(fileId);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        } else if (fileId.endsWith(BLOCKLY_SOURCE_EXTENSION)) {</span>
<span class="fc" id="L346">          sourceNode = new YoungAndroidBlocksNode(fileId);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        } else if (fileId.endsWith(CODEBLOCKS_SOURCE_EXTENSION)) {</span>
<span class="nc" id="L348">          String blocklyFileName =</span>
<span class="nc" id="L349">              fileId.substring(0, fileId.lastIndexOf(CODEBLOCKS_SOURCE_EXTENSION))</span>
              + BLOCKLY_SOURCE_EXTENSION;
<span class="nc bnc" id="L351" title="All 2 branches missed.">          if (!sourceFiles.contains(blocklyFileName)) {</span>
            // This is an old project that hasn't been converted yet. Convert
            // the blocks file to Blockly format and name. Leave the old
            // codeblocks file around for now (for debugging) but don't send it to the client.
<span class="nc" id="L355">            String blocklyFileContents = convertCodeblocksToBlockly(userId, projectId, fileId);</span>
<span class="nc" id="L356">            storageIo.addSourceFilesToProject(userId, projectId, false, blocklyFileName);</span>
<span class="nc" id="L357">            storageIo.uploadFileForce(projectId, blocklyFileName, userId, blocklyFileContents,</span>
                StorageUtil.DEFAULT_CHARSET);
<span class="nc" id="L359">            sourceNode = new YoungAndroidBlocksNode(blocklyFileName);</span>
          }
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        } else if (fileId.endsWith(YAIL_FILE_EXTENSION)) {</span>
<span class="fc" id="L362">          sourceNode = new YoungAndroidYailNode(fileId);</span>
        }
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (sourceNode != null) {</span>
<span class="fc" id="L365">          String packageName = StorageUtil.getPackageName(sourceNode.getQualifiedName());</span>
<span class="fc" id="L366">          ProjectNode packageNode = packagesMap.get(packageName);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">          if (packageNode == null) {</span>
<span class="fc" id="L368">            packageNode = new YoungAndroidPackageNode(packageName, packageNameToPath(packageName));</span>
<span class="fc" id="L369">            packagesMap.put(packageName, packageNode);</span>
<span class="fc" id="L370">            sourcesNode.addChild(packageNode);</span>
          }
<span class="fc" id="L372">          packageNode.addChild(sourceNode);</span>
        }
      }
<span class="fc" id="L375">    }</span>

<span class="fc" id="L377">    return rootNode;</span>
  }

  /*
   * Convert the contents of the codeblocks file named codeblocksFileId
   * to blockly format and return the blockly contents.
   */
  private String convertCodeblocksToBlockly(String userId, long projectId,
      String codeblocksFileId) {
    // TODO(sharon): implement this!
<span class="nc" id="L387">    return &quot;&quot;;</span>
  }

  @Override
  public long addFile(String userId, long projectId, String fileId) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (fileId.endsWith(FORM_PROPERTIES_EXTENSION) ||</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        fileId.endsWith(BLOCKLY_SOURCE_EXTENSION)) {</span>
      // If the file to be added is a form file or a blocks file, add a new form file, a new
      // blocks file, and a new yail file (as a placeholder for later code generation)
<span class="nc" id="L396">      String qualifiedFormName = YoungAndroidSourceNode.getQualifiedName(fileId);</span>
<span class="nc" id="L397">      String formFileName = YoungAndroidFormNode.getFormFileId(qualifiedFormName);</span>
<span class="nc" id="L398">      String blocklyFileName = YoungAndroidBlocksNode.getBlocklyFileId(qualifiedFormName);</span>
<span class="nc" id="L399">      String yailFileName = YoungAndroidYailNode.getYailFileId(qualifiedFormName);</span>

<span class="nc" id="L401">      List&lt;String&gt; sourceFiles = storageIo.getProjectSourceFiles(userId, projectId);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">      if (!sourceFiles.contains(formFileName) &amp;&amp;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">          !sourceFiles.contains(blocklyFileName) &amp;&amp;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">          !sourceFiles.contains(yailFileName)) {</span>

<span class="nc" id="L406">        String formFileContents = getInitialFormPropertiesFileContents(qualifiedFormName);</span>
<span class="nc" id="L407">        storageIo.addSourceFilesToProject(userId, projectId, false, formFileName);</span>
<span class="nc" id="L408">        storageIo.uploadFileForce(projectId, formFileName, userId, formFileContents,</span>
            StorageUtil.DEFAULT_CHARSET);

<span class="nc" id="L411">        String blocklyFileContents = getInitialBlocklySourceFileContents(qualifiedFormName);</span>
<span class="nc" id="L412">        storageIo.addSourceFilesToProject(userId, projectId, false, blocklyFileName);</span>
<span class="nc" id="L413">        storageIo.uploadFileForce(projectId, blocklyFileName, userId, blocklyFileContents,</span>
            StorageUtil.DEFAULT_CHARSET);

<span class="nc" id="L416">        String yailFileContents = &quot;&quot;;  // start empty</span>
<span class="nc" id="L417">        storageIo.addSourceFilesToProject(userId, projectId, false, yailFileName);</span>
<span class="nc" id="L418">        return storageIo.uploadFileForce(projectId, yailFileName, userId, yailFileContents,</span>
            StorageUtil.DEFAULT_CHARSET);
      } else {
<span class="nc" id="L421">        throw new IllegalStateException(&quot;One or more files to be added already exists.&quot;);</span>
      }

    } else {
<span class="nc" id="L425">      return super.addFile(userId, projectId, fileId);</span>
    }
  }

  @Override
  public long deleteFile(String userId, long projectId, String fileId) {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">    if (fileId.endsWith(FORM_PROPERTIES_EXTENSION) ||</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        fileId.endsWith(BLOCKLY_SOURCE_EXTENSION)) {</span>
      // If the file to be deleted is a form file or a blocks file, delete both the form file
      // and the blocks file. Also, if there was a codeblocks file laying around
      // for that same form, delete it too (if it doesn't exist the delete
      // for it will be a no-op).
<span class="fc" id="L437">      String qualifiedFormName = YoungAndroidSourceNode.getQualifiedName(fileId);</span>
<span class="fc" id="L438">      String formFileName = YoungAndroidFormNode.getFormFileId(qualifiedFormName);</span>
<span class="fc" id="L439">      String blocklyFileName = YoungAndroidBlocksNode.getBlocklyFileId(qualifiedFormName);</span>
<span class="fc" id="L440">      String codeblocksFileName = YoungAndroidBlocksNode.getCodeblocksFileId(qualifiedFormName);</span>
<span class="fc" id="L441">      String yailFileName = YoungAndroidYailNode.getYailFileId(qualifiedFormName);</span>
<span class="fc" id="L442">      storageIo.deleteFile(userId, projectId, formFileName);</span>
<span class="fc" id="L443">      storageIo.deleteFile(userId, projectId, blocklyFileName);</span>
<span class="fc" id="L444">      storageIo.deleteFile(userId, projectId, codeblocksFileName);</span>
<span class="fc" id="L445">      storageIo.deleteFile(userId, projectId, yailFileName);</span>
<span class="fc" id="L446">      storageIo.removeSourceFilesFromProject(userId, projectId, true,</span>
          formFileName, blocklyFileName, codeblocksFileName, yailFileName);
<span class="fc" id="L448">      return storageIo.getProjectDateModified(userId, projectId);</span>

    } else {
<span class="nc" id="L451">      return super.deleteFile(userId, projectId, fileId);</span>
    }
  }

  /**
   * Constructs a RpcResult object that indicates that a file was too big to send.
   *
   * @param size size of the aia
   * @return a new RpcResult with information for rendering an error in the client
   */
  private RpcResult fileTooBigResult(double size) {
<span class="nc" id="L462">    return new RpcResult(413, &quot;&quot;, String.format(Locale.getDefault(),</span>
<span class="nc" id="L463">        &quot;{\&quot;maxSize\&quot;:%d,\&quot;aiaSize\&quot;:%f}&quot;, MAX_PROJECT_SIZE.get(), size / MB));</span>
  }

  /**
   * Make a request to the Build Server to build a project.  The Build Server will asynchronously
   * post the results of the build via the {@link com.google.appinventor.server.ReceiveBuildServlet}
   * A later call will need to be made by the client in order to get those results.
   *
   * @param user the User that owns the {@code projectId}.
   * @param projectId  project id to be built
   * @param nonce random string used to find resulting APK from unauth context
   * @param target  build target (optional, implementation dependent)
   *
   * @return an RpcResult reflecting the call to the Build Server
   */
  @Override
  public RpcResult build(User user, long projectId, String nonce, String target,
      boolean secondBuildserver, boolean isAab) {
<span class="nc" id="L481">    String userId = user.getUserId();</span>
<span class="nc" id="L482">    String projectName = storageIo.getProjectName(userId, projectId);</span>
<span class="nc" id="L483">    String outputFileDir = BUILD_FOLDER + '/' + target;</span>

    // Store the userId and projectId based on the nonce

<span class="nc" id="L487">    storageIo.storeNonce(nonce, userId, projectId);</span>

    // Delete the existing build output files, if any, so that future attempts to get it won't get
    // old versions.
<span class="nc" id="L491">    List&lt;String&gt; buildOutputFiles = storageIo.getProjectOutputFiles(userId, projectId);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">    for (String buildOutputFile : buildOutputFiles) {</span>
<span class="nc" id="L493">      storageIo.deleteFile(userId, projectId, buildOutputFile);</span>
<span class="nc" id="L494">    }</span>
<span class="nc" id="L495">    URL buildServerUrl = null;</span>
<span class="nc" id="L496">    ProjectSourceZip zipFile = null;</span>
    try {
<span class="nc" id="L498">      buildServerUrl = new URL(getBuildServerUrlStr(</span>
<span class="nc" id="L499">          user.getUserEmail(),</span>
          userId,
          projectId,
          secondBuildserver,
          outputFileDir,
          isAab));
<span class="nc" id="L505">      HttpURLConnection connection = (HttpURLConnection) buildServerUrl.openConnection();</span>
<span class="nc" id="L506">      connection.setDoOutput(true);</span>
<span class="nc" id="L507">      connection.setRequestMethod(&quot;POST&quot;);</span>

<span class="nc" id="L509">      BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(connection.getOutputStream());</span>
<span class="nc" id="L510">      FileExporter fileExporter = new FileExporterImpl();</span>
<span class="nc" id="L511">      zipFile = fileExporter.exportProjectSourceZip(userId, projectId, false,</span>
          /* includeAndroidKeystore */ true,
        projectName + &quot;.aia&quot;, true, false, true, false);
      // The code below tests the size of the compressed project before
      // we send it off to the buildserver. When using URLFetch we know that
      // this size is limited to 10MB based on Google's documentation.
      // It isn't clear if this is also enforced in the Java 8 environment
      // when not using URLFetch. However we are being conservative for now.
      // Keep in mind that large projects can lead to large APK files which
      // may not be loadable into many memory restricted devices, so we
      // may not want to encourage large projects...
<span class="nc bnc" id="L522" title="All 2 branches missed.">      if (zipFile.getContent().length &gt; MAX_PROJECT_SIZE.get() * MB) {</span>
<span class="nc" id="L523">        return fileTooBigResult(zipFile.getContent().length);</span>
      }
<span class="nc" id="L525">      bufferedOutputStream.write(zipFile.getContent());</span>
<span class="nc" id="L526">      bufferedOutputStream.flush();</span>
<span class="nc" id="L527">      bufferedOutputStream.close();</span>

<span class="nc" id="L529">      int responseCode = 0;</span>
<span class="nc" id="L530">      responseCode = connection.getResponseCode();</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">      if (responseCode != HttpURLConnection.HTTP_OK) {</span>
        // Put the HTTP response code into the RpcResult so the client code in BuildCommand.java
        // can provide an appropriate error message to the user.
        // NOTE(lizlooney) - There is some weird bug/problem with HttpURLConnection. When the
        // responseCode is 503, connection.getResponseMessage() returns &quot;OK&quot;, but it should return
        // &quot;Service Unavailable&quot;. If I make the request with curl and look at the headers, they
        // have the expected error message.
        // For now, the moral of the story is: don't use connection.getResponseMessage().
<span class="nc" id="L539">        String error = &quot;Build server responded with response code &quot; + responseCode + &quot;.&quot;;</span>
        try {
<span class="nc" id="L541">          String content = readContent(connection.getInputStream());</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">          if (content != null &amp;&amp; !content.isEmpty()) {</span>
<span class="nc" id="L543">            error += &quot;\n&quot; + content;</span>
          }
<span class="nc" id="L545">        } catch (IOException e) {</span>
          // No content. That's ok.
<span class="nc" id="L547">        }</span>
        try {
<span class="nc" id="L549">          String errorContent = readContent(connection.getErrorStream());</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">          if (errorContent != null &amp;&amp; !errorContent.isEmpty()) {</span>
<span class="nc" id="L551">            error += &quot;\n&quot; + errorContent;</span>
          }
<span class="nc" id="L553">        } catch (IOException e) {</span>
          // No error content. That's ok.
<span class="nc" id="L555">        }</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (responseCode == HttpURLConnection.HTTP_CONFLICT) {</span>
          // The build server is not compatible with this App Inventor instance. Log this as severe
          // so the owner of the app engine instance will know about it.
<span class="nc" id="L559">          LOG.severe(error);</span>
        }

<span class="nc" id="L562">        return new RpcResult(responseCode, &quot;&quot;, StringUtils.escape(error));</span>
      } else {
        // We get here if all went well and we sent the job to the
        // buildserver. Below we read the response, but throw it away.
        // We don't really care what was said. But we need to empty out
        // the TCP Stream or App Engine will abort the connection by
        // sending a RST packet instead of re-using it or closing it
        // cleanly (by sending a FIN packet). Aborting connections can
        // have a negative effect on some buildserver infrastructures,
        // particularly those based on docker swarm (as of 2018).
<span class="nc" id="L572">        readContent(connection.getInputStream());</span>
      }
<span class="nc" id="L574">    } catch (MalformedURLException e) {</span>
<span class="nc" id="L575">      CrashReport.createAndLogError(LOG, null,</span>
<span class="nc" id="L576">          buildErrorMsg(&quot;MalformedURLException&quot;, buildServerUrl, userId, projectId), e);</span>
<span class="nc" id="L577">      return new RpcResult(false, &quot;&quot;, e.getMessage());</span>
<span class="nc" id="L578">    } catch (IOException e) {</span>
      // As of App Engine 1.9.0 we get these when UrlFetch is asked to send too much data
<span class="nc bnc" id="L580" title="All 2 branches missed.">      int zipFileLength = zipFile == null ? -1 : zipFile.getContent().length;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">      if (zipFileLength &gt;= MAX_PROJECT_SIZE.get() * MB) {</span>
<span class="nc" id="L582">        return fileTooBigResult(zipFileLength);</span>
      } else {
<span class="nc" id="L584">        return new RpcResult(false, &quot;&quot;, e.getMessage());</span>
      }
<span class="nc" id="L586">    } catch (EncryptionException e) {</span>
<span class="nc" id="L587">      CrashReport.createAndLogError(LOG, null,</span>
<span class="nc" id="L588">          buildErrorMsg(&quot;EncryptionException&quot;, buildServerUrl, userId, projectId), e);</span>
<span class="nc" id="L589">      return new RpcResult(false, &quot;&quot;, e.getMessage());</span>
<span class="nc" id="L590">    } catch (RuntimeException e) {</span>
      // In particular, we often see RequestTooLargeException (if the zip is too
      // big) and ApiProxyException. There may be others.
<span class="nc" id="L593">      Throwable wrappedException = e;</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">      if (e instanceof ApiProxy.RequestTooLargeException &amp;&amp; zipFile != null) {</span>
<span class="nc" id="L595">        int zipFileLength = zipFile.getContent().length;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (zipFileLength &gt;= MAX_PROJECT_SIZE.get() * MB) {</span>
<span class="nc" id="L597">          return fileTooBigResult(zipFileLength);</span>
        } else {
<span class="nc" id="L599">          wrappedException = new IllegalArgumentException(</span>
              &quot;Sorry, project was too large to package (&quot; + zipFileLength + &quot; bytes)&quot;);
        }
<span class="nc" id="L602">      } else {</span>
        // Unexpected runtime error
<span class="nc" id="L604">        CrashReport.createAndLogError(LOG, null,</span>
<span class="nc" id="L605">            buildErrorMsg(&quot;RuntimeException&quot;, buildServerUrl, userId, projectId), wrappedException);</span>
      }
<span class="nc" id="L607">      return new RpcResult(false, &quot;&quot;, wrappedException.getMessage());</span>
<span class="nc" id="L608">    }</span>
<span class="nc" id="L609">    return new RpcResult(true, &quot;Building &quot; + projectName, &quot;&quot;);</span>
  }

  public RpcResult loginToGallery(String userId) {
<span class="nc" id="L613">    String token = GalleryToken.makeToken(userId, 0, &quot;&quot;);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">    if (galleryId.isEmpty()) {</span>
<span class="nc" id="L615">      return new RpcResult(-1, &quot;&quot;, &quot;Gallery Not Properly Configured&quot;);</span>
    } else {
<span class="nc" id="L617">      return new RpcResult(0, galleryLocation + &quot;/loginfromappinventor?token=&quot; + token + &quot;&amp;id=&quot; + galleryId, &quot;&quot;);</span>
    }
  }

  /*
   * Send a project to the new Gallery
   *
   * @param userId the user id
   * @param projectId the project ID to send
   */

  @Override
  public RpcResult sendToGallery(String userId, long projectId) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L631">      LOG.info(&quot;sendToGallery userId = &quot; + userId + &quot; projectId = &quot; + projectId);</span>
    }
<span class="nc bnc" id="L633" title="All 2 branches missed.">    if (galleryId.isEmpty()) {</span>
<span class="nc" id="L634">      return new RpcResult(-1, &quot;&quot;, &quot;Gallery Not Properly Configured&quot;);</span>
    }
<span class="nc" id="L636">    String projectName = storageIo.getProjectName(userId, projectId);</span>
<span class="nc" id="L637">    URL newGalleryUrl = null;</span>
<span class="nc" id="L638">    ProjectSourceZip zipFile = null;</span>
    try {
<span class="nc" id="L640">      FileExporter fileExporter = new FileExporterImpl();</span>
<span class="nc" id="L641">      zipFile = fileExporter.exportProjectSourceZip(userId, projectId, false,</span>
        false, projectName + &quot;.aia&quot;, false, false, true, true);
<span class="nc" id="L643">      String token = GalleryToken.makeToken(userId, projectId, projectName);</span>
<span class="nc" id="L644">      newGalleryUrl = new URL(galleryLocation + &quot;/fromappinventor?token=&quot; +</span>
        token + &quot;&amp;id=&quot; + galleryId);
<span class="nc" id="L646">      HttpURLConnection connection = (HttpURLConnection) newGalleryUrl.openConnection();</span>
<span class="nc" id="L647">      connection.setDoOutput(true);</span>
<span class="nc" id="L648">      connection.setRequestMethod(&quot;POST&quot;);</span>
<span class="nc" id="L649">      BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(connection.getOutputStream());</span>
<span class="nc" id="L650">      bufferedOutputStream.write(zipFile.getContent());</span>
<span class="nc" id="L651">      bufferedOutputStream.flush();</span>
<span class="nc" id="L652">      bufferedOutputStream.close();</span>
<span class="nc" id="L653">      int responseCode = 0;</span>
<span class="nc" id="L654">      responseCode = connection.getResponseCode();</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">      if (responseCode != HttpURLConnection.HTTP_OK) {</span>
<span class="nc" id="L656">        String error = &quot;Got response code &quot; + responseCode + &quot;.&quot;;</span>
        try {
<span class="nc" id="L658">          String content = readContent(connection.getInputStream());</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">          if (content != null &amp;&amp; !content.isEmpty()) {</span>
<span class="nc" id="L660">            error += &quot;\n&quot; + content;</span>
          }
<span class="nc" id="L662">        } catch (IOException e) {</span>
          // No content. That's ok.
<span class="nc" id="L664">        }</span>
        try {
<span class="nc" id="L666">          String errorContent = readContent(connection.getErrorStream());</span>
<span class="nc bnc" id="L667" title="All 4 branches missed.">          if (errorContent != null &amp;&amp; !errorContent.isEmpty()) {</span>
<span class="nc" id="L668">            error += &quot;\n&quot; + errorContent;</span>
          }
<span class="nc" id="L670">        } catch (IOException e) {</span>
          // No error content. That's ok.
<span class="nc" id="L672">        }</span>
<span class="nc" id="L673">        LOG.severe(&quot;SendToGallery: &quot; + error);</span>
<span class="nc" id="L674">        return new RpcResult(-1, &quot;&quot;, error);</span>
      } else {
<span class="nc" id="L676">        String returl = readContent(connection.getInputStream()); // Need to drain any response</span>
<span class="nc" id="L677">        return new RpcResult(0, returl, &quot;&quot;);</span>
      }
<span class="nc" id="L679">    } catch (Exception e) {</span>
<span class="nc" id="L680">      throw CrashReport.createAndLogError(LOG, null, e.getMessage(), e);</span>
    }
  }

  /**
   * Load a project from the new Gallery. This code will reach out and fetch
   * a project from the Gallery. We then store it with the user's projects and
   * return a UserProject object back to the user's browser so it can load the
   * newly stored project into the App Inventor UI.
   *
   * JIS: We send a GET request to the gallery which returns a
   * protocol buffer. This buffer contains the meta data we need for
   * the project (at this point, just its name). It may contain the
   * content itself (as a ZIP blob) or it may indicate that the ZIP
   * blob is at a different URL which we will then fetch (when we
   * implement it :-) ). This permits us to diversify the storage of
   * project AIA files. In fact it will let us leave projects from the
   * older gallery implementation in place in Google Cloud Storage
   * provided that we make those AIA files publicly readable (which I
   * believe they are)
   */

  @Override
  public UserProject loadFromGallery(String userId, String aGalleryId) throws IOException {
<span class="nc bnc" id="L704" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L705">      LOG.info(&quot;Before getURLContents (meta)&quot;);</span>
    }
<span class="nc" id="L707">    final byte [] responseContent = getURLContents(galleryLocation + &quot;/aia/&quot; + aGalleryId);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L709">      LOG.info(&quot;After getURLContents (meta)&quot;);</span>
    }
    byte[] aiaContents;
<span class="nc bnc" id="L712" title="All 2 branches missed.">    if (responseContent == null) {</span>
<span class="nc" id="L713">      throw new IOException(&quot;Cannot contact the Gallery, Try again later&quot;);</span>
    }
<span class="nc" id="L715">    GalleryProtobuf.content content = GalleryProtobuf.content.parseFrom(responseContent);</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">    if (content.getCtype() == GalleryProtobuf.content.ContentType.DIRECT) {</span>
<span class="nc" id="L718">      aiaContents = content.getContent().toByteArray();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">    } else if (content.getCtype() == GalleryProtobuf.content.ContentType.URL) {</span>
<span class="nc" id="L720">      LOG.info(&quot;Before getURLContents (data)&quot;);</span>
<span class="nc" id="L721">      aiaContents = getURLContents(content.getUrlcontent());</span>
<span class="nc" id="L722">      LOG.info(&quot;After getURLContents (data)&quot;);</span>
    } else {
<span class="nc" id="L724">      throw new IOException(&quot;Unknown storage format for project.&quot;);</span>
    }
<span class="nc" id="L726">    FileImporter fileImporter = new FileImporterImpl();</span>
    // Generate a unique project name (only if conflict)
<span class="nc" id="L728">    LOG.info(&quot;Before checking project names&quot;);</span>
<span class="nc" id="L729">    String newProjectName = verifyProjectName(userId, content.getProjectname());</span>
<span class="nc" id="L730">    LOG.info(&quot;After checking project names&quot;);</span>
    try {
<span class="nc" id="L732">      UserProject retval = fileImporter.importProject(userId, newProjectName,</span>
        new ByteArrayInputStream(aiaContents));
<span class="nc" id="L734">      LOG.info(&quot;After fileImporter&quot;);</span>
<span class="nc" id="L735">      return retval;</span>
<span class="nc" id="L736">    } catch (FileImporterException e) {</span>
<span class="nc" id="L737">      throw new IOException(&quot;Unable to import project&quot;);</span>
    }
  }

  String buildErrorMsg(String exceptionName, URL buildURL, String userId, long projectId) {
<span class="pc bpc" id="L742" title="2 of 4 branches missed.">    return &quot;Request to build failed with &quot; + exceptionName</span>
      + &quot;, user=&quot; + userId + &quot;, project=&quot; + projectId
      + &quot;, build URL is &quot; + (buildURL != null ? buildURL : &quot;null&quot;) + &quot; [&quot;
<span class="pc" id="L745">      + (buildURL != null ? buildURL.toString().length() : &quot;n/a&quot;) + &quot;]&quot;;</span>
  }

  // Note that this is a function rather than just a constant because we assume it will get
  // a little more complicated when we want to get the URL from an App Engine config file or
  // command line argument.
  private String getBuildServerUrlStr(String userName, String userId,
    long projectId, boolean secondBuildserver, String fileName, boolean isAab)
      throws EncryptionException {
<span class="nc bnc" id="L754" title="All 2 branches missed.">    UriBuilder uriBuilder = new UriBuilder(</span>
        &quot;http://&quot;
<span class="nc" id="L756">            + (secondBuildserver ? buildServerHost2.get() : buildServerHost.get())</span>
            + &quot;/buildserver/build-all-from-zip-async&quot;)
<span class="nc" id="L758">        .add(&quot;uname&quot;, userName)</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        .add(&quot;callback&quot;, &quot;http://&quot; + getCurrentHost() + ServerLayout.ODE_BASEURL_NOAUTH +</span>
            ServerLayout.RECEIVE_BUILD_SERVLET + &quot;/&quot; +
<span class="nc" id="L761">            Security.encryptUserAndProjectId(userId, projectId) + &quot;/&quot; +</span>
            fileName)
<span class="nc" id="L763">        .add(&quot;ext&quot;, isAab ? &quot;aab&quot; : &quot;apk&quot;);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">    if (sendGitVersion.get()) {</span>
<span class="nc" id="L765">      uriBuilder.add(&quot;gitBuildVersion&quot;, GitBuildId.getVersion());</span>
    }
<span class="nc" id="L767">    return uriBuilder.build();</span>
  }

  private String getCurrentHost() {
<span class="nc bnc" id="L771" title="All 2 branches missed.">    if (Server.isProductionServer()) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">      if (StringUtils.isNullOrEmpty(appengineHost.get())) {</span>
<span class="nc" id="L773">        String applicationVersionId = SystemProperty.applicationVersion.get();</span>
<span class="nc" id="L774">        String applicationId = SystemProperty.applicationId.get();</span>
<span class="nc" id="L775">        return applicationVersionId + &quot;.&quot; + applicationId + &quot;.appspot.com&quot;;</span>
      } else {
<span class="nc" id="L777">        return appengineHost.get();</span>
      }
    } else {
      // TODO(user): Figure out how to make this more generic
<span class="nc" id="L781">      return &quot;localhost:8888&quot;;</span>
    }
  }

  /*
   * Reads the UTF-8 content from the given input stream.
   */
  private static String readContent(InputStream stream) throws IOException {
<span class="nc bnc" id="L789" title="All 2 branches missed.">    if (stream != null) {</span>
<span class="nc" id="L790">      BufferedReader reader = new BufferedReader(new InputStreamReader(stream, &quot;UTF-8&quot;));</span>
      try {
<span class="nc" id="L792">        return CharStreams.toString(reader);</span>
      } finally {
<span class="nc" id="L794">        reader.close();</span>
      }
    }
<span class="nc" id="L797">    return null;</span>
  }

  /**
   * Check if there are any build results available for the given user's project
   *
   * @param user the User that owns the {@code projectId}.
   * @param projectId  project id to be built
   * @param target  build target (optional, implementation dependent)
   * @return an RpcResult reflecting the call to the Build Server. The following values may be in
   *         RpcResult.result:
   *            0:  Build is done and was successful
   *            1:  Build is done and was unsuccessful
   *            2:  Yail generation failed
   *           -1:  Build is not yet done.
   */
  @Override
  public RpcResult getBuildResult(User user, long projectId, String target) {
<span class="nc" id="L815">    String userId = user.getUserId();</span>
<span class="nc" id="L816">    String buildOutputFileName = BUILD_FOLDER + '/' + target + '/' + &quot;build.out&quot;;</span>
<span class="nc" id="L817">    List&lt;String&gt; outputFiles = storageIo.getProjectOutputFiles(userId, projectId);</span>
<span class="nc" id="L818">    RpcResult buildResult = new RpcResult(-1,</span>
<span class="nc" id="L819">        Integer.toString(getCurrentProgress(user, projectId, target)),</span>
        &quot;&quot;); // Build not finished
<span class="nc bnc" id="L821" title="All 2 branches missed.">    for (String outputFile : outputFiles) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">      if (buildOutputFileName.equals(outputFile)) {</span>
<span class="nc" id="L823">        String outputStr = storageIo.downloadFile(userId, projectId, outputFile, &quot;UTF-8&quot;);</span>
        try {
<span class="nc" id="L825">          JSONObject buildResultJsonObj = new JSONObject(outputStr);</span>
<span class="nc" id="L826">          buildResult = new RpcResult(buildResultJsonObj.getInt(&quot;result&quot;),</span>
<span class="nc" id="L827">                                      buildResultJsonObj.getString(&quot;output&quot;),</span>
<span class="nc" id="L828">                                      buildResultJsonObj.getString(&quot;error&quot;),</span>
                                      outputStr);
<span class="nc" id="L830">        } catch (JSONException e) {</span>
<span class="nc" id="L831">          buildResult = new RpcResult(1, &quot;&quot;, &quot;&quot;);</span>
<span class="nc" id="L832">        }</span>
<span class="nc" id="L833">        break;</span>
      }
<span class="nc" id="L835">    }</span>
<span class="nc" id="L836">    return buildResult;</span>
  }

  /**
   * Check if there are any build progress available for the given user's project
   *
   * @param user the User that owns the {@code projectId}.
   * @param projectId  project id to be built
   * @param target  build target (optional, implementation dependent)
   */
  public int getCurrentProgress(User user, long projectId, String target) {
<span class="nc" id="L847">    return storageIo.getBuildStatus(user.getUserId(), projectId);</span>
  }

  /**
   * This method reads from a stream based on the passed connection. It reads
   * the content as bytes, so it can deal with binary files
   *
   * @param connection the connection to read from
   * @return the contents of the stream
   * @throws IOException if it cannot read from the http connection
   */
  private static byte[] getResponseBytes(HttpURLConnection connection) throws IOException {
    // Use the content encoding to convert bytes to characters.
<span class="nc" id="L860">    InputStream input = connection.getInputStream();</span>
<span class="nc" id="L861">    int bytesRead = 0;</span>
<span class="nc" id="L862">    int contentLength = connection.getContentLength();</span>
<span class="nc" id="L863">    LOG.info(&quot;contentLength = &quot; + contentLength);</span>
<span class="nc" id="L864">    byte buffer[] = new byte[contentLength];</span>
    while (true) {
<span class="nc" id="L866">      int i = input.read(buffer, bytesRead, contentLength - bytesRead);</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">      if (i &lt; 0) {</span>
<span class="nc" id="L868">        break;</span>
      }
<span class="nc" id="L870">      bytesRead += i;</span>
<span class="nc" id="L871">    }</span>
<span class="nc" id="L872">    LOG.info(&quot;Done, contentLenght = &quot; + contentLength + &quot; bytesRead = &quot; + bytesRead);</span>
<span class="nc" id="L873">    return buffer;</span>
  }

  /*
   * Verify that the input projectName is unique among the user's
   * projects.
   */

  private String verifyProjectName(String userId, String projectName) {
<span class="nc" id="L882">    projectName = projectName.replace(&quot; &quot;, &quot;_&quot;);</span>
<span class="nc" id="L883">    int count = 0;</span>
<span class="nc" id="L884">    List&lt;Long&gt; projectIds = storageIo.getProjects(userId);</span>
<span class="nc" id="L885">    List&lt;UserProject&gt; projects = storageIo.getUserProjects(userId, projectIds);</span>
<span class="nc" id="L886">    TreeSet&lt;String&gt; projectNames = new TreeSet();</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">    for (UserProject project : projects) {</span>
<span class="nc" id="L888">      projectNames.add(project.getProjectName());</span>
<span class="nc" id="L889">    }</span>
<span class="nc" id="L890">    String baseProjectName = projectName;</span>
    while (true) {
<span class="nc bnc" id="L892" title="All 2 branches missed.">      if (count &gt; 100) {</span>
<span class="nc" id="L893">        throw CrashReport.createAndLogError(LOG, null, &quot;Count exceeded in verifyProjectName&quot;, null);</span>
      }
<span class="nc bnc" id="L895" title="All 2 branches missed.">      if (!projectNames.contains(projectName)) {</span>
<span class="nc" id="L896">        return projectName;</span>
      }
<span class="nc" id="L898">      count += 1;</span>
<span class="nc" id="L899">      projectName = baseProjectName + &quot;_&quot; + count;</span>
    }
  }

  private static byte [] getURLContents(String url) throws IOException {
    try {
<span class="nc" id="L905">      URL Url = new URL(url);</span>
<span class="nc" id="L906">      HttpURLConnection connection = (HttpURLConnection) Url.openConnection();</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">      if (connection != null) {</span>
        try {
<span class="nc" id="L909">          connection.setRequestMethod(&quot;GET&quot;);</span>
<span class="nc" id="L910">          connection.setFollowRedirects(true);</span>
<span class="nc" id="L911">          int responseCode = connection.getResponseCode();</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">          if (responseCode != HttpURLConnection.HTTP_OK) {</span>
<span class="nc" id="L913">            throw new IOException(&quot;Got bad response code on read: &quot; + responseCode);</span>
          }
<span class="nc" id="L915">          return getResponseBytes(connection);</span>
<span class="nc" id="L916">        } catch (ConnectException e) {</span>
<span class="nc" id="L917">          throw new IOException(&quot;Connection Failure: &quot; + e.getMessage());</span>
<span class="nc" id="L918">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L919">          throw new IOException(&quot;No Such Object: &quot; + url);</span>
        } finally {
<span class="nc bnc" id="L921" title="All 2 branches missed.">          if (connection != null) {</span>
            try {
<span class="nc" id="L923">              LOG.info(&quot;Before CLOSE&quot;);</span>
<span class="nc" id="L924">              connection.disconnect();</span>
<span class="nc" id="L925">              LOG.info(&quot;After CLOSE&quot;);</span>
<span class="nc" id="L926">            } catch (Exception e) {</span>
              // XXX
<span class="nc" id="L928">            }</span>
          }
        }
      } else {
<span class="nc" id="L932">        return null;</span>
      }
<span class="nc" id="L934">    } catch (Exception e) {</span>
<span class="nc" id="L935">      throw new IOException(&quot;Unable to read content: &quot; + e.getMessage());</span>
    }

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>